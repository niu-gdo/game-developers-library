# Game Developer's Survival Guide

By Jake Rogers

## Introduction

It is difficult to think of a statement less controversial than "Making video games is *hard*". Video games involve a meticulous interplay between a vast and diverse cast of computer science disciplines which make them pretty complicated software!

Even though modern game engines make entrance to the hobby easier than ever, it is still easy to fall into a series of pitfalls which can greatly test your motivation to continue.

From those who have graduated from the school of hard knocks, we present to beginners a list of hot tips as you begin your journey into game development, the *Game Developer's Survival Guide*!



## Hot Tips for Beginners

##### Start Small
Game development is a practice driven discipline, even experienced coders are going to need to start with very small projects to learn how to build an entire game. Diving straight into your dream game is a classic beginner's trap!

When we say small, we mean small. Try recreating other simple games like Flappy Bird, Cookie Clicker, Pong, Astroids- that kind of stuff. 

This also greatly reduces burn out by creating a definite "end point" for your project. You may find that many of your great game ideas are not as fun to work on as you expected, and not having a designated time to wrap the project up can be very draining in that case.

##### Give Yourself a Timeline
You won't be good at this initially since you will not know what you are capable of, but try to give yourself a specific amount of time to complete your next project- one or two weeks should be enough time to finish an adequately sized game for a beginner.

##### Finish Your Projects
It is impossible to overstate how important it is to finish the projects that you start. At the end of the day, your ability to create *good* games is going to hinge upon your knowledge of the **entire** game development process. 

You need to know how to take a game from start-to-finish, how to build an archetecture which can scale to a full project, what challenges lie beyond the halfway point, and how to build a good foundation. You will often need to know how to do these things before you even write your first couple scripts in a new, serious project. **You will not learn these skills by making a dozen prototypes or abandoning projects a quarter-way through**.

##### Find Good, Long-Form Learning Material
There exist many long-form tutorial series for any game engine which give a step-by-step guide on building an *entire* game. These are invaluable resources, as they will show you techniques and strategies you cannot find in shorter tutorials or by experimenting on your own. These types of guides are good once you have learned the basics and made at least one very small game.

Ironically, shorter tutorials you find for making individual, smaller systems or game mechanics are *not* useful for beginners, because only experienced developers will know how to integrate and modify the given system into their own projects. Knowing how to make the glue that binds multiple systems together is the real challenge, and it is not learned by just making isolated systems.

If you can afford it, there are many extremely good online courses on sites like Udemy which do exactly this. Just be sure to vet whatever you are buying and do not hesistate to refund a course if it is not what you expected.

##### Create a Plan, Project Board, or Design Document
**The later a decision about your game's design is made, the more expensive that decision is**. In our case, suddenly deciding that we want to add some feature that we did not initially account for can be a very messy ordeal.

Therefore, planning out what you want your game to be *as precisely as possible* before starting is an extremely smart move. You can even use web applications like [Trello](https://www.trello.com) to plan your work into individual tasks, which helps keep you oriented as you go along. Planning, just like anything else, is a skill you will improve at as you gain experience.

##### Source Control is Non-Negotiable!
Whether it be GitHub, Plastic SCM, or some other SC solution, use it for *all* of your projects. It can be very easy to accidentally break something in your game- particularly in subtle ways which may not manifest until later. Using source control allows you to revert back to earlier iterations. Branching allows you to prototype new features without affecting your main game.

Source Control is arguably required for team projects as well, so learn it as soon as possible.

##### Use Public Assets
Even if you are an experienced 2D / 3D artist, asset creation is a time consuming process which is particularly unnecessary for beginners. Use **publically-licensed** assets for the majority of your game, and occasionally practice making your own resources for important game elements, whenever it is easy to do, or to fill in the gaps.

##### Join a Community
Not only does joining a community of other game developers let you see inspiring work and get advice, but it also gives you a group of people who may be willing to test, play, and talk about your games when you finish them. Putting a ton of work into a project to only have one or two people play it is a huge gut punch!

**Do not just be a user though**, express interest in other people's projects and offer to try them- it is a small action that means a lot to developers, and they may return the favor!

##### Hold on to Your Old Projects
Your old projects are your notes, there is no shame in using an old script you made in another project for something you are working on now.

##### Be a Double-Dipper
For many tasks in game development, there are almost always multiple ways of achieving the desired outcome.

When you learn something new, you should try to find another alternative guide which teaches the same concept. You will likely find some slightly different approach which can recontextualize the problem, give you a solution you like more, or allow you to create a hybrid of the two styles.

##### Avoid Overengineering
The line between creating a robust, scalable design for your game and overengineering is very fine.

On one end, it is very easy to write short-sighted code which will inevitably need to be refactored to play nicely with other scripts- a massive headache.

However, it is very easy to overcorrect for this and spend far, far too much time creating a complex solution to an easy problem in a game which does not need complexity. The two fixes to this problem are gaining start-to-finish project experience and having a rigid, pre-planned design for your game which informs us on how much effort needs to go into engineering.

##### Schedule Refinement
We are often tempted to make things look pretty and optimize our code as we create them. However, this is dangerous because we may later find out that things we have made are not good for our game or need to be total redesigned.

If this occurs, the time we spent refining and optmizing become wasted. Or worse, we may become attached to a bad feature because we spent time on it.

When you are planning out the design of your game **set aside time for refinement and optimization**- a place where you will evaluate everything thus far, run the profiler to check performance, and only then make refinement changes.
