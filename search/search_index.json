{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Game Developer's Library!","text":"<p>The Game Developer's Library (GDL) is a repository of articles which serve to educate readers on independent game development. Articles, guides, and tutorials about game development, be it engine-specific guides, general development strategies, or even lower level concepts in computer graphics find a home here!</p>"},{"location":"#bulletin-board","title":"Bulletin Board","text":"<p> New to game development? Check out our Game Developer's Survival Guide for tips about getting started!</p> <p> Looking for a place to get started? Our Unity: First Steps Series will get you on the path toward making two small games.</p>"},{"location":"#browse-our-library","title":"Browse Our Library!","text":""},{"location":"#tutorials","title":"Tutorials","text":""},{"location":"#guides","title":"Guides","text":""},{"location":"#articles","title":"Articles","text":""},{"location":"#contribution","title":"Contribution","text":"<p>Members of NIU's Indie Game Developers Organization may become contributors by contacting this repository's administrator at this page's GitHub Repo</p> <ul> <li>Using MkDocs</li> <li>Contributing New Pages</li> </ul>"},{"location":"articles/articles-index/","title":"Articles","text":"<p>Our articles are shorter entries which aim to educate readers about a specific topic related to game development or individual tools.</p>"},{"location":"articles/articles-index/#general-game-development","title":"General Game Development","text":"<ul> <li>Game Developer's Survival Guide!</li> <li>Frame Updates and Frame Rate Dependency (Coming Soon!)</li> </ul>"},{"location":"articles/articles-index/#mathematics","title":"Mathematics","text":"<ul> <li>Basic Linear Algebra for Game Developers (Coming Soon!)</li> <li>Basic Trigonometry for Game Developers (Coming Soon!)</li> </ul>"},{"location":"articles/articles-index/#unity","title":"Unity","text":"<ul> <li>Unity Overview</li> <li>Scriptable Render Pipelines (SRP)</li> </ul>"},{"location":"articles/game-developers-survival-guide/","title":"Game Developer's Survival Guide","text":"<p>By Jake Rogers</p>"},{"location":"articles/game-developers-survival-guide/#introduction","title":"Introduction","text":"<p>It is difficult to think of a statement less controversial than \"Making video games is hard\". Video games involve a meticulous interplay between a vast and diverse cast of computer science disciplines which make them pretty complicated software!</p> <p>Even though modern game engines make entrance to the hobby easier than ever, it is still easy to fall into a series of pitfalls which can greatly test your motivation to continue.</p> <p>From those who have graduated from the school of hard knocks, we present to beginners a list of hot tips as you begin your journey into game development, the Game Developer's Survival Guide!</p>"},{"location":"articles/game-developers-survival-guide/#hot-tips-for-beginners","title":"Hot Tips for Beginners","text":""},{"location":"articles/game-developers-survival-guide/#start-small","title":"Start Small","text":"<p>Game development is a practice driven discipline, even experienced coders are going to need to start with very small projects to learn how to build an entire game. Diving straight into your dream game is a classic beginner's trap!</p> <p>When we say small, we mean small. Try recreating other simple games like Flappy Bird, Cookie Clicker, Pong, Astroids- that kind of stuff. </p> <p>This also greatly reduces burn out by creating a definite \"end point\" for your project. You may find that many of your great game ideas are not as fun to work on as you expected, and not having a designated time to wrap the project up can be very draining in that case.</p>"},{"location":"articles/game-developers-survival-guide/#give-yourself-a-timeline","title":"Give Yourself a Timeline","text":"<p>You won't be good at this initially since you will not know what you are capable of, but try to give yourself a specific amount of time to complete your next project- one or two weeks should be enough time to finish an adequately sized game for a beginner.</p>"},{"location":"articles/game-developers-survival-guide/#finish-your-projects","title":"Finish Your Projects","text":"<p>It is impossible to overstate how important it is to finish the projects that you start. At the end of the day, your ability to create good games is going to hinge upon your knowledge of the entire game development process. </p> <p>You need to know how to take a game from start-to-finish, how to build an archetecture which can scale to a full project, what challenges lie beyond the halfway point, and how to build a good foundation. You will often need to know how to do these things before you even write your first couple scripts in a new, serious project. You will not learn these skills by making a dozen prototypes or abandoning projects a quarter-way through.</p>"},{"location":"articles/game-developers-survival-guide/#find-good-long-form-learning-material","title":"Find Good, Long-Form Learning Material","text":"<p>There exist many long-form tutorial series for any game engine which give a step-by-step guide on building an entire game. These are invaluable resources, as they will show you techniques and strategies you cannot find in shorter tutorials or by experimenting on your own. These types of guides are good once you have learned the basics and made at least one very small game.</p> <p>Ironically, shorter tutorials you find for making individual, smaller systems or game mechanics are not useful for beginners, because only experienced developers will know how to integrate and modify the given system into their own projects. Knowing how to make the glue that binds multiple systems together is the real challenge, and it is not learned by just making isolated systems.</p> <p>If you can afford it, there are many extremely good online courses on sites like Udemy which do exactly this. Just be sure to vet whatever you are buying and do not hesistate to refund a course if it is not what you expected.</p>"},{"location":"articles/game-developers-survival-guide/#create-a-plan-project-board-or-design-document","title":"Create a Plan, Project Board, or Design Document","text":"<p>The later a decision about your game's design is made, the more expensive that decision is. In our case, suddenly deciding that we want to add some feature that we did not initially account for can be a very messy ordeal.</p> <p>Therefore, planning out what you want your game to be as precisely as possible before starting is an extremely smart move. You can even use web applications like Trello to plan your work into individual tasks, which helps keep you oriented as you go along. Planning, just like anything else, is a skill you will improve at as you gain experience.</p>"},{"location":"articles/game-developers-survival-guide/#source-control-is-non-negotiable","title":"Source Control is Non-Negotiable!","text":"<p>Whether it be GitHub, Plastic SCM, or some other SC solution, use it for all of your projects. It can be very easy to accidentally break something in your game- particularly in subtle ways which may not manifest until later. Using source control allows you to revert back to earlier iterations. Branching allows you to prototype new features without affecting your main game.</p> <p>Source Control is arguably required for team projects as well, so learn it as soon as possible.</p>"},{"location":"articles/game-developers-survival-guide/#use-public-assets","title":"Use Public Assets","text":"<p>Even if you are an experienced 2D / 3D artist, asset creation is a time consuming process which is particularly unnecessary for beginners. Use publically-licensed assets for the majority of your game, and occasionally practice making your own resources for important game elements, whenever it is easy to do, or to fill in the gaps.</p>"},{"location":"articles/game-developers-survival-guide/#join-a-community","title":"Join a Community","text":"<p>Not only does joining a community of other game developers let you see inspiring work and get advice, but it also gives you a group of people who may be willing to test, play, and talk about your games when you finish them. Putting a ton of work into a project to only have one or two people play it is a huge gut punch!</p> <p>Do not just be a user though, express interest in other people's projects and offer to try them- it is a small action that means a lot to developers, and they may return the favor!</p>"},{"location":"articles/game-developers-survival-guide/#hold-on-to-your-old-projects","title":"Hold on to Your Old Projects","text":"<p>Your old projects are your notes, there is no shame in using an old script you made in another project for something you are working on now.</p>"},{"location":"articles/game-developers-survival-guide/#be-a-double-dipper","title":"Be a Double-Dipper","text":"<p>For many tasks in game development, there are almost always multiple ways of achieving the desired outcome.</p> <p>When you learn something new, you should try to find another alternative guide which teaches the same concept. You will likely find some slightly different approach which can recontextualize the problem, give you a solution you like more, or allow you to create a hybrid of the two styles.</p>"},{"location":"articles/game-developers-survival-guide/#avoid-overengineering","title":"Avoid Overengineering","text":"<p>The line between creating a robust, scalable design for your game and overengineering is very fine.</p> <p>On one end, it is very easy to write short-sighted code which will inevitably need to be refactored to play nicely with other scripts- a massive headache.</p> <p>However, it is very easy to overcorrect for this and spend far, far too much time creating a complex solution to an easy problem in a game which does not need complexity. The two fixes to this problem are gaining start-to-finish project experience and having a rigid, pre-planned design for your game which informs us on how much effort needs to go into engineering.</p>"},{"location":"articles/game-developers-survival-guide/#schedule-refinement","title":"Schedule Refinement","text":"<p>We are often tempted to make things look pretty and optimize our code as we create them. However, this is dangerous because we may later find out that things we have made are not good for our game or need to be total redesigned.</p> <p>If this occurs, the time we spent refining and optmizing become wasted. Or worse, we may become attached to a bad feature because we spent time on it.</p> <p>When you are planning out the design of your game set aside time for refinement and optimization- a place where you will evaluate everything thus far, run the profiler to check performance, and only then make refinement changes.</p>"},{"location":"articles/unity-articles/unity-overview/","title":"Unity Overview","text":"<p>By Jake Rogers</p>"},{"location":"articles/unity-articles/unity-overview/#project-type-support","title":"Project Type Support","text":"<p>Unity, like other popular game engines, has support for making many types of games. Here are some brief notes about Unity's ability to make certain types of games.</p> <ul> <li> <p>3-D: 3D has been supported in Unity since its 1.0 release all the way back in 2005! Arguably being a specialty amongst the other game types, you will find no lack of support here. Unity has been used in many high-profile 3D games, such as Escape From Tarkov, Rust, and Risk of Rain 2.</p> </li> <li> <p>2-D: 2D in Unity has gotten some flak in the past for not being as intuitive as 3D. In fact, you will find that Unity's 2D is obstensibly a 3D game loosely constrained to a single plane. Certain workflow tools for things like tilemapping are not as sophisticated as they are in other 2D capable engines. However, most of these concerns come from older posts and threads, as Unity's 2D has come a long way and is very functional. In fact, many of the most popular 2D games are made with Unity, such as RimWorld, Hollow Knight, and Cuphead.</p> </li> <li> <p>Augmented Reality (AR): Unity is a very popular choice for Augmented Reality software, where virtual game elements are projected on top of the physical world. Read More</p> </li> <li> <p>Virtual Reality (VR): Many of the most popular VR games are made with Unity, such as VRChat, Blade &amp; Sorcery, Beat Saber, and BONEWORKS. </p> </li> <li> <p>Non-Game Applications: Unity can also be used in general as a tool for showcases, interactive visualizations, and simulations. There are likely better tools available for achieving these goals, but it is a nice option if you are already versed in the engine!</p> </li> </ul>"},{"location":"articles/unity-articles/unity-overview/#more-details-to-come-later","title":"More Details to Come Later!","text":""},{"location":"articles/unity-articles/unity-render-pipelines/","title":"Scriptable Render Pipelines","text":"<p>By Jake Rogers</p>"},{"location":"articles/unity-articles/unity-render-pipelines/#renderers","title":"Renderers","text":"<p>When picking a project template, you will notice that there are multiple different types of the same template:</p> <ul> <li>3D</li> <li>3D (URP)</li> <li>3D (HDRP)</li> <li>2D</li> <li>2D (URP)</li> </ul> <p>The difference here is the type of Scriptable Render Pipeline (SRP) being used. SRPs allow for Unity to provide multiple different ways for projects to handle rendering graphics from the game to screens. Each choice render pipeline has some different features.</p> <ul> <li>Default (Built-In Renderer): With no pipeline specified, Unity defaults to the Built-in Renderer. This is what Unity used before SRPs were rolled out in around 2019. While it is general-purpose, it has limited customization options.<ul> <li>Note that the Built-In Renderer is not a SRP; it is a legacy renderer from before SRPs were introduced.</li> </ul> </li> <li>Universial Render Pipeline (URP): The URP is an easy to customize, performant render pipeline designed for a large range of target platforms, from low-end mobiles to PCs. This makes URP a good choice for games with low or medium graphical fidelity, though one can still create very impressive scenes with it.<ul> <li>For a brief time, URP was formerly known as the Light-Weight Render Pipeline, or (LWRP).</li> </ul> </li> <li>High-Definition Render Pipeline (HDRP): The HDRP is designed to produce AAA quality graphics specifically targeted as high-end platforms, making it a good choice for games trying to have cutting-edge graphics.</li> </ul>"},{"location":"articles/unity-articles/unity-render-pipelines/#which-renderer-should-i-use","title":"Which Renderer Should I use?","text":"<p>The Built-In Renderer, URP, and HDRP are available for 3D games, while 2D only has the Built-In Renderer and URP. </p> <p>In most cases, you will want to go for the Universial Render Pipeline for your projects. You likely will not have assets to high-fidelity assets to make the cutting edge rendering worth it, and you may find it has a heavier load on your editor. Further, the Built-In Render is arguably superceded by the URP. Developers report getting better frame-rates with URP while having easier customization options and better fidelity. 2D URP games also get access to optimized, slick 2D lighting options.</p>"},{"location":"articles/unity-articles/unity-render-pipelines/#switching-renderers","title":"Switching Renderers","text":"<p>It is technically possible to convert an existing project to a new renderer. However, it can be a massive hassle to do so, as nearly all materials in the project will need to be adjusted in someway, and certain features may become broken.</p> <p>If you are importing assets from old sources into a URP / HDRP project, you may need to use the Render Pipeline Converter to rebuild your shaders and materials if they were made with the Built-In Renderer.</p>"},{"location":"contribution/making-new-pages/","title":"Making New Pages","text":"<p>MkDocs allows you to create a new page in GDL by simply creating a new markdown page and merging it into our main branch.</p>"},{"location":"contribution/making-new-pages/#install-mkdocs","title":"Install MkDocs","text":"<p>If you haven't already, install MkDocs and Material for MkDocs.</p>"},{"location":"contribution/making-new-pages/#clone-and-branch-the-repo","title":"Clone and Branch the Repo","text":""},{"location":"contribution/making-new-pages/#clone","title":"Clone","text":"<p>Go to our GitHub Repo and clone the repository to your system. You can do so using a terminal with Git installed: <code>git clone https://github.com/niu-gdo/game-developers-library.git</code> </p>"},{"location":"contribution/making-new-pages/#branch","title":"Branch","text":"<p>You will want to make any changes in a local branch to avoid messing up your main. Ensure that you are on the main branch, then checkout to a new one. <pre><code>git checkout main\ngit checkout -b &lt;branch-name&gt;\n</code></pre> When in doubt, aim for descriptive branches rather than short ones. <code>making-pages</code> is not as good as <code>create-making-pages-article</code> or <code>fix-typo-in-scene-loading-chapter-9</code>.</p>"},{"location":"contribution/making-new-pages/#create-a-new-page","title":"Create a New Page","text":"<p>To create a new page, you must add a new .md file somewhere in the docs/ directory. The docs/ directory contains many subdirectories for various types of files, such as for guides, articles, showcase, etc. Create your file in the most appropriate location (ask if unsure!).</p> <p>Furthermore, if your page requires some locally hosted media (images, gifs), create a directory in the same location as your .md file. Give it the same name as your .md file, but add '-res' to the end.</p> <pre><code># You can add files through other methods as well, of course.\ntouch docs/contribution/making-new-pages.md\nmkdir docs/contribution/making-new-pages-res\n</code></pre>"},{"location":"contribution/making-new-pages/#link-your-page","title":"Link your page","text":"<p>GDL requires new pages to be explicitly routed in the <code>mkdocs.yml</code> file. You will see a <code>nav</code> section with entries given as <code>'- &lt;page-name&gt;': &lt;route-to-page&gt;</code></p> <p>You should add an entry to the nav configuration that mimics where you placed your .md file. Indentation matters here! <pre><code>(mkdocs.yml)\n...\nnav:\n    - Home: 'index.md'\n...\n    - Contribution:\n        - 'Using MkDocs': 'contribution/mkdocs-usage.md'\n        - 'Making New Pages': 'contribution/making-new-pages.md' # &lt;!--\n</code></pre></p> <p>Once your page is linked, you should be able to run <code>mkdocs serve</code> and navigate to your new page with the nav section!</p>"},{"location":"contribution/making-new-pages/#push-to-github","title":"Push to GitHub","text":"<p>When you are done (or at any point along the process), use <code>git add .</code> and <code>git commit -m '&lt;commit message&gt;'</code> from the project's root to commit your changes.  </p> <p>When your final commit is done and you feel ready to push the branch, execute <code>git push &lt;branch-name&gt;</code>. This should create a branch on our GitHub Repo.</p> <p>If you get an error regarding no upstream branch, do the following: <pre><code>git remote add origin https://github.com/niu-gdo/game-developers-library.git\ngit push -u origin &lt;branch-name&gt;\n</code></pre></p>"},{"location":"contribution/making-new-pages/#create-a-pull-request","title":"Create a Pull Request","text":"<p>Visit the GitHub Repo on a web browser and go to Pull Requests -&gt; Create Pull Request. Select main as the base, and your new branch as the compare. <code>base: main &lt;- compare: &lt;branch-name&gt;</code>, then create the pull request.</p> <p>In the description of the merge, write what changes your branch brings. In the top right, request some reviewers. At minimum, request the review of Jake Rogers (Explosive Eggshells).</p>"},{"location":"contribution/making-new-pages/#updating-a-pull-request","title":"Updating a Pull Request","text":"<p>Reviewers will inspect any files added or changed in your pull request, and approve it if all looks good. If something needs to be changed, you can go back to your local branch, commit those changes, then run <code>git push &lt;branch-name&gt;</code> once again to update the pull request.</p>"},{"location":"contribution/making-new-pages/#merge-changes","title":"Merge Changes","text":"<p>Once your pull request is approved, you should have an option to merge your changes into the main branch (do it)! You will then be given the option of deleting your branch, which you likely should do.</p> <p>When changes are pushed to the main branch, GitHub will automatically redeploy GDL. You can inspect this process by going to the \"Actions\" tab on the repository. Once the rebuild is done, your changes will show up on GDL! \\o/</p>"},{"location":"contribution/mkdocs-usage/","title":"Using MkDocs","text":"<p>By Jake Rogers</p>"},{"location":"contribution/mkdocs-usage/#mkdocs","title":"MkDocs","text":"<p>GDL uses MkDocs to convert .md files into html &amp; CSS files. When MkDocs builds, it finds any .md files found within the /docs/ directory and generates a cohesive website from what it finds, featuring a few extra goodies:</p> <ul> <li>Navigation window, which groups pages based on the docs/ subdirectory structure</li> <li>A search bar, which not only finds pages, but keywords within pages.</li> <li>Per-page table of contents, constructed from using headings.</li> <li>Themes and dark mode.</li> </ul> <p>All that is to say, you can create sleek pages as easily as you would create a markdown file!</p> <p>MkDoc's Website</p>"},{"location":"contribution/mkdocs-usage/#material-for-mkdocs","title":"Material for MkDocs","text":"<p>GDL also uses Material for MkDocs as a theme template throughout the site.</p> <p>Squidfunk's Material for MkDocs</p>"},{"location":"contribution/mkdocs-usage/#installation","title":"Installation","text":"<p>NIU Game Developers Organization members only need two things to contribue:</p> <ul> <li>A GitHub account added to our organization (Contact administrators of NIU-GDO).  </li> <li>A UNIX terminal, capable of installing the mkdocs package and pip.<ul> <li>Windows users can easily use WSL2 or a Virtual Machine for this purpose.</li> </ul> </li> </ul> <p>In a UNIX terminal, do the following: 1. Install mkdocs. Run <code>sudo apt install mkdocs</code> 2. Install pip. Run <code>sudo apt install python3-pip</code> 3. Using pip, install Material for MkDocs. Run <code>pip install mkdocs-material</code> </p> <p>You should now have both MkDocs and Material for MkDocs installed!</p>"},{"location":"contribution/mkdocs-usage/#editing-with-mkdocs","title":"Editing with MkDocs","text":"<p>While some text editors allow you to see formatted .md files as you edit them, you will notice that your local branches of GDL do not look anything like the website. This, of course, is because MkDocs has not yet converted the .md files to the formal website. </p> <p>If you want mkdocs to build the actual site, run <code>mkdocs build</code> in the root directory of the project, and you will see a site/ directory produced. This directory will contain all of the files needed for the actual website, including an index.html.</p>"},{"location":"contribution/mkdocs-usage/#mkdocs-serve","title":"MkDocs Serve","text":"<p>We don't, however, want to build mkdocs everytime we make a change. Fortunately, you can run <code>mkdocs serve</code> instead to start a live-hosted process for the site. The terminal will display a link you can open on a web browser to view the page, and any changes to .md files will automatically reload the page and display the changes!</p> <p>Use Ctrl+C to stop the <code>mkdocs serve</code> process.</p>"},{"location":"guides/guides-index/","title":"Guides","text":"<p>Created: March 5th, 2023</p> <p>Updated: September 4th, 2023</p> <p>Our guides are more generally structured pages which serve as both an introduction to and a repository for various topics that would be too complex to sum up in an article. They will provide enough information to become familiar with a concept, but will out source further reading to other places.</p>"},{"location":"guides/guides-index/#unity","title":"Unity","text":""},{"location":"guides/guides-index/#unreal","title":"Unreal","text":"<p>Knowledgable about the Unreal engine? Help us out by creating some literature here!</p>"},{"location":"guides/guides-index/#godot","title":"Godot","text":"<p>Godot guides coming in the future, especially once version 4 has mutured a bit.</p>"},{"location":"guides/unity-guides/cs-language-features/","title":"C# Coding Tricks","text":"<p>By: Jake Rogers Created: September 4th, 2023</p>"},{"location":"guides/unity-guides/cs-language-features/#overview","title":"Overview","text":"<p>This guide serves as an introduction to a plethora of coding features for the C# programming language as it pertains to video game scripting. This is made as a useful primer for those familiar with other statically typed languages, but are newer to C# (or just happened to miss learning some of these techniques).</p> <p>Note that inclusion here doesn't indicate \"Best Practice\", it's just nice to know as an option or when reading code produced by others. </p> Tip <p>You can right-click on Table of Contents entires and Copy Link Address to get a link directly to a particular entry on this page!</p>"},{"location":"guides/unity-guides/cs-language-features/#short-hands-convenience-features","title":"Short-hands &amp; Convenience Features","text":""},{"location":"guides/unity-guides/cs-language-features/#expression-bodies","title":"Expression Bodies","text":"<p>Expression bodies are a convenient way to write brief one liners within a class: <pre><code>private int width;\nprivate int height;\n\n// Traditional\npublic void MultiplyWidthLong(float magnitude)\n{\n    width *= magnitude;\n}\n\n// Expression bodies (Does the same as above)\npublic void MultiplyWidth(float magnitude) =&gt; width *= magnitude;\n\n//****\n\n// Traditional\npublic int CalculateAreaLong()\n{\n    return width * height;\n}\n\n// Note: 'Return' is implicit\npublic int CalculateArea() =&gt; width * height;\n</code></pre> This can also be particularly useful to write simple event handlers.</p> <p>Note that there was no need to specify <code>return</code> on a non-void expression bodied function: It is assumed that the one-liner will return the result of the instruction.</p> <p>Learn More</p>"},{"location":"guides/unity-guides/cs-language-features/#lambda-expressions","title":"Lambda Expressions","text":"<p>Some functions may themselves call for a reference to a different function within their parameter list. Lambda Expressions, written similarly to Expression Bodies, can create Anonymous Functions as an argument rather than having to write down the function separately: <pre><code>// 'processorFunc' accepts any function with one int parameter and returns an int.\nprivate void ProcessArray(ref int[] values, Func&lt;int, int&gt; processorFunc)\n{\n    for (int i = 0; i &lt; nums.Length; i++)\n    {\n        nums[i] = processor(nums[i]);\n    }\n}\n\nprivate int MinusOne(int x) =&gt; x - 1;\n\nprivate void foo()\n{\n    int[] nums = {1, 2, 3, 4};\n\n    // Traditional use: Pass an existing function\n    ProcessArray(ref nums, MinusOne);   // {0, 1, 2, 3}\n\n    // Lambda Function: Create the expression in-line\n    ProcessArray(ref nums, (int x) =&gt; x + 5); // Add 5 to each element. {5, 6, 7, 8}\n    ProcessArray(ref nums, (int x) =&gt; x * 10); // 10x each element. {50, 60, 70, 80}\n\n}\n</code></pre></p> <p>This is very useful when dealing with higher-level design strategies which allow functions to be passed in to configure the behavior of a construct, such as Object Pools and State Machines.</p> <p>Learn More</p>"},{"location":"guides/unity-guides/cs-language-features/#format-strings","title":"Format Strings","text":""},{"location":"guides/unity-guides/cs-language-features/#stringformat","title":"string.Format","text":"<p><code>string.Format</code> allows you to emplace placeholders into a string for cleaner and more modular string formatting: <pre><code>string firstName = \"John\";\nstring lastName = \"Doe\";\nfloat netWorth = 1894731.2168784215;\n\nConsole.WriteLine(\n    string.Format(\"Member: {0}, {1} | Net Worth: ${2:0.00}\",\n    lastName,\n    firstName,\n    netWorth));\n// Doe, John | Net Worth:  $1894731.21\n</code></pre> The placeholders can be given additional formatting to change how the string is emplaced. For example, the Net Worth display was set to only print two decimals. Visit the docs to see all the options.</p>"},{"location":"guides/unity-guides/cs-language-features/#interpolated-strings","title":"Interpolated Strings","text":"<p>Interpolated Strings (known as format strings in other languages) are a less versatile but very convenient way of formatting a string. </p> <p>Invoke them by putting <code>$</code> in front of a string literal and using <code>{...}</code> to emplace variables. Expressions also work.</p> <p><pre><code>string firstName = \"John\";\nstring lastName = \"Doe\";\nfloat netWorth = 1894731.2168784215;\n\nConsole.WriteLine($\"Member: {lastName}, {firstName} | Net Worth: ${netWorth}\");\n// Doe, John | Net Worth: $1894731.2168784215\n</code></pre> Interpolated strings are very convenient, and remove the need to do ugly string concatenation (I.E <code>\"a = \" + a + \", b = \" + b;</code>).</p>"},{"location":"guides/unity-guides/cs-language-features/#constructor-reuse","title":"Constructor Reuse","text":"<p>When writing multiple constructors for the same class, it can be useful to reuse the implementation of another constructor when writing a larger one:</p> <p><pre><code>public class Damager\n{\n    float DamageAmount;\n    float ArmorPenetration;\n    DamageType DamageType;\n    float DebuffBuildUp;\n\n    public Damager()\n    {\n        DamageAmount = 1;\n        ArmorPenetration = 0f;\n        DamageType = DamageType.Ballistic;\n        DebuffBuildUp = 0f;\n    }\n\n    // Calls the default constructor with the damage amount and type specified,\n    // but penetration and build up defaulted to 0.\n    // Note that the brackets are intentionally left empty, as no further definition is necessary.\n    public Damager(float damageAmount, DamageType damageType) \n        : this(damageAmount, 0f, damageType, 0f) { }\n\n    // Only specify damage. Default penetration to 0, type to fire, and 15 build up\n    public Damager(float damageAmount) : this(damageAmount, 0f, DamageType.Fire, 15f);\n}\n</code></pre> In the example above we create a fully-encompassing constructor to initialize every member. Then, we create more specific constructors which allow only a few fields to be specified while all others use a default value.</p>"},{"location":"guides/unity-guides/cs-language-features/#properties","title":"Properties","text":"<p>Properties can be described as more advanced data accessors for a class. They provide cleaner ways to implement things such as Getters &amp; Setters and shorthand accessors. </p>"},{"location":"guides/unity-guides/cs-language-features/#getter-setters","title":"Getter / Setters","text":"<p>The Getter / Setter pattern can be written fairly easily via properties. The below example allows the private <code>healthPercentage</code> to be accessed publicly, and written to with some error checking: <pre><code>public class CharacterHealth\n{\n    private float healthPercentage;\n\n    public float HealthPercentage\n    {\n        get { return healthPercentage; }\n        set { healthPercentage = Mathf.Clamp01(value)} // Disallow setting outside of the [0, 1] domain\n    }\n}\n// In another class....\nprivate void foo()\n{\n    CharacterHealth health;\n    health.HealthPercentage = 20.5;    // Value gets clamped to 1, healthPercentage is now 1.\n\n    Console.Log(health.HealthPercentage)\n}\n</code></pre></p> <p>The above could also be written like so using expression bodies: <pre><code>public class CharacterHealth\n{\n    private float healthPercentage;\n\n    public float HealthPercentage { get =&gt; healthPercentage; set =&gt; Mathf.Clamp01(value); }\n}\n</code></pre></p> <p>Learn More</p>"},{"location":"guides/unity-guides/cs-language-features/#write-restricted-public-member","title":"Write Restricted Public Member","text":"<p>Properties can also be used to create regular public members that have restricted set access:</p> <pre><code>public float HealthPercentage { get; private set;} \n// This member can be gotten externally, but only written internally.\n</code></pre> <p>Note that this differs from a <code>readonly</code> member, as readonly members cannot be reassigned by any scope once the class' constructor exits.</p>"},{"location":"guides/unity-guides/cs-language-features/#derived-properties","title":"Derived Properties","text":"<p>Properties can also allow the results of functions to be returned in a way similar to member fields. This is useful for creating derived or composite fields which are accessed in ways similar to a public member:</p> <pre><code>public class Rectangle\n{\n    public float width = 2;\n    public float height = 5;\n\n    public float Area { get =&gt; width * height; }\n}\n\n// In another class...\nprivate void foo()\n{\n    Rectangle r;\n    Console.WriteLine(r.Area) // 10\n    // Note: Area is not accessed like a function using '()'.\n}\n</code></pre>"},{"location":"guides/unity-guides/cs-language-features/#functional-features","title":"Functional Features","text":""},{"location":"guides/unity-guides/cs-language-features/#parameter-modifiers","title":"Parameter Modifiers","text":"<p>Here are a few things you can do with parameters to functions you write:</p>"},{"location":"guides/unity-guides/cs-language-features/#pass-by-reference-ref-modifier","title":"Pass By Reference (<code>ref</code>) Modifier","text":"<p>Similar to other languages, objects passed as <code>ref</code> are passed as a direct reference to the object given as a parameter rather than a copy. This means changes to said <code>ref</code> parameter in the function will directly change the original variable rather than a copy.</p> <ul> <li><code>ref</code> requires that the parameter be initialized before it can be passed into the function.</li> <li>Calling function must use the <code>ref</code> keyword when providing the <code>ref</code> argument.</li> <li>Read more on Pass By Reference.</li> </ul> <pre><code>class Quad\n{\n    public int Width;\n    public int Height;\n\n    Quad(int width, int height) \n    {\n        Width = width;\n        Height = height;\n    }\n\n    Print() =&gt; Console.WriteLine($\"Width: {Width} | Height: {Height}\");\n\n}\n\nprivate void foo(ref Quad s)\n{\n    s.Width *= 2;\n    s.Height *= 2;\n}\n\nprivate void bar()\n{\n    Quad q;\n    // Note, calling foo with q would be illegal because\n    // it is not initialized yet!\n    q = new Quad(5, 10);\n\n    foo(ref q); // Note: Must use 'ref' before any ref parameter\n    q.Print(); // Width: 10 | Height: 20\n}\n</code></pre>"},{"location":"guides/unity-guides/cs-language-features/#out-modifier","title":"<code>out</code> modifier","text":"<p><code>out</code> works similarly to Pass by Reference, with two major differences:</p> <ol> <li>The <code>out</code> parameter no longer needs to be initialized prior to usage in the function call. In fact, it doesn't even need to exist, as the compiler will declare the variable for you if it doesn't exist.</li> <li>A function with <code>out</code> parameters must ensure that all <code>out</code> parameter get initialized at the end of all code paths.</li> </ol> <pre><code>private void foo(out int number) =&gt; number = 10;\n\nprivate void bar()\n{\n    foo(out int num);\n    Console.WriteLine(num); \n    // Perfectly legal, num is declared and initialized by foo!\n}\n</code></pre> <p>This is a nice way to implement functions which like to return more than one value (Assuming you don't want to use a tuple).</p> <p>Learn More</p>"},{"location":"guides/unity-guides/cs-language-features/#params-modifier","title":"<code>params</code> Modifier","text":"<p><code>params</code>: Parameter arrays allow callers of the method to provide an any-sized list of parameters, which will then be received as an array.</p> <ul> <li>Parameter arrays must be the final parameter in the signature, as there is no delimiter to stop adding elements to the array.</li> <li>The caller can also pass in an array as well, as long as it matches the type of the parameter array.</li> <li>An empty array is also valid.</li> </ul> <pre><code>private void PrintNums(params int[] nums)\n{\n    foreach (int x in nums)\n    {\n        Console.Write($\"{x},\");\n    }\n}\n\n\nprivate void Foo()\n{\n    PrintNums(1, 5, 7, 10); // 1, 5, 7, 10,\n    PrintNums(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);   // 5, ..., 15,\n    PrintNums() // (Empty is also valid: Nothing printed.)\n\n    int[] nums = {10, 20, 30};\n    PrintNums(nums) // 10, 20, 30,\n}\n</code></pre> <p>Learn More</p>"},{"location":"guides/unity-guides/cs-language-features/#named-and-optional-parameters","title":"Named and Optional Parameters","text":"<p>Optional Parameters allow parameters to be ignored or provided by the calling function. If ignored, they will use a default value.</p> <ul> <li>Optionals must be defined at the end of the parameter list in a block, as required (AKA 'normal') parameters need to be referenced positionally.</li> <li>The calling function specifies which optionals to provide by referencing their name.</li> </ul> <p><pre><code>private void WeirdCalculation(\n    float a, float b, float sigma=0.5, float mu=1.0) {/*...*/}\n\nprivate void foo()\n{\n    WeirdCalculation(10, 5, mu=1.5);\n    // Sigma uses default of '0.5' since we didn't specify.\n}\n</code></pre> In C#, function calls can provide parameters by name rather than positionally.</p> <ul> <li>This can be useful for code readability, as it strongly associates the parameter with it's purpose in the function.</li> <li>You can mix named parameters with positional parameters as long as the overall positioning of all parameters isn't violated. However, it is usually best to either use all named arguments in a function call, or none at all.</li> </ul> <pre><code>private void foo(string firstName, string lastName, int age, float height) {/*...*/}\n\nprivate void bar()\n{\n    foo(firstName: \"John\", lastName: \"Doe\", age: 50, height: 140);\n\n    // Any order is fine as long as they are all named.\n    foo(age: 30, height: 30, lastName: \"Mann\", firstName: \"Mini\");\n\n    //This is technically fine.\n    foo(firstName: \"Biggy\", \"Brigs\", age: 15, height: 2000);\n\n    // This is -&gt;not&lt;- fine!\n    foo(age: 15, \"Iam\", \"Afailure\", 145);\n}\n</code></pre>"},{"location":"guides/unity-guides/cs-language-features/#xml-documentation","title":"XML Documentation","text":"<p>XML Documentation is a .NET standard for in-file C# documentation. Following the standard allows your code to be automatically attributed with documentation by various doc parsers.</p> <p>For example, using XML doc on a function allows the details of the function to be provided in compatible IDE tooltips. <pre><code>/// &lt;summary&gt;\n/// Returns the value with the lowest absolute value\n/// &lt;/summary&gt;\n/// &lt;param name=\"values\"&gt;Collection of values&lt;/param&gt;\n/// &lt;returns&gt;Element of values with lowest absolute value&lt;/returns&gt;\npublic static float AbsMin(params float[] values) {/*...*/}\n</code></pre></p> <p>Visual Studio's IntelliSense will generate the following tooltip when <code>AbsMin</code> is invoked or hovered over: </p> <p>When writing a function with <code>param</code> tags, each respective <code>param</code> doc will show up as it is being provided in the function call.</p> <p>It is best to read the relevant .NET doc page for more details. Some IDEs (such as Visual Studio) will automatically generate a skeleton for the docs when you write <code>///</code> above a function or class definition.</p>"},{"location":"guides/unity-guides/cs-language-features/#tuples","title":"Tuples","text":"<p>C# can enclose multiple variables into a Tuple. This is especially useful for returning multiple pieces of related data from a function:</p> <p><pre><code>// Note: Return type is a (float, float) tuple\nprivate (float latitude, float longitude) GetGPSLocation()\n{\n    return (15.1568752, 184.12019);\n}\n\nprivate void foo()\n{\n    // Use the 'var' auto typer to get tuples.\n    var location = GetGPSLocation();\n    Console.WriteLine(\n        $\"Latitude: {location.latitude} | Longitude: {location.longitude}\");\n}\n</code></pre> Note that the members of a tuple are referenced by name. Also, the <code>var</code> keyword works similarly to <code>auto</code> in C, the data type is assumed from the right-hand side of the assignment.</p> <ul> <li>Learn More (Tuples)</li> <li>Learn More (var)</li> </ul>"},{"location":"guides/unity-guides/cs-language-features/#linq","title":"LINQ","text":"<p>Language Integrated Queries (LINQ), in short, allow you to run SQL-style commands on enumerable collections, such as Lists, arrays, etc. This allows you to interact with object collections in a way similar to a database.</p> <p>While this is typically overkill on many standard collection operations, it can be useful for smart manipulation or extraction of data from very large collections. Video games often have an internal database of object definitions (Items, Weapons, characters, stats, etc) which can leverage LINQ.</p> <p>Here is an example taken from Microsoft's .NET Documentation Site<sup>1</sup>:</p> <pre><code>#using System.Linq; // Note: LINQ must be included for use.\n\n// Specify the data source.\nint[] scores = { 97, 92, 81, 60 };\n\n// Define the query expression.\nIEnumerable&lt;int&gt; scoreQuery =\n    from score in scores\n    where score &gt; 80\n    select score;\n\n// Execute the query.\nforeach (int i in scoreQuery)\n{\n    Console.Write(i + \" \");\n}\n\n// Output: 97 92 81\n</code></pre> <p>It is worth noting that the creation of a query expression (line 7 of the example above) does not execute the query. It creates a construct whose execution is then deferred to a later step (the <code>foreach</code> in the above example)</p> <p>Including the LINQ library into your file also grants you access to some useful collection operations, such as <code>FirstOrDefault</code>, <code>Count</code>, <code>Distinct</code>, <code>Max</code>, <code>OrderBy</code>, <code>Select</code>, and much more.</p> <p><code>FirstOrDefault</code> is particularly useful, as it allows you to get the first item out of a collection while specifying a fallback (the <code>default</code>) if the collection is empty.</p> <p>It is best to take some time to read over the following MS .NET Doc pages to learn more:</p> <ul> <li>LINQ Overview: An overview of what LINQ is.</li> <li>Introduction to LINQ Queries: A practical look into how LINQ is used.</li> <li>System.LINQ.Enumerable Methods: Additional collection methods provided by including the LINQ library.</li> </ul>"},{"location":"guides/unity-guides/cs-language-features/#references","title":"References","text":"<ol> <li>Microsoft's .NET Documentation Page</li> </ol>"},{"location":"guides/unity-guides/unity-guides-index/","title":"Unity Guides","text":"<p>Created: September, 1st 2023 Updated: September, 4th 2023</p>"},{"location":"guides/unity-guides/unity-guides-index/#unity-editor","title":"Unity Editor","text":"<ul> <li>Useful Unity Packages (Coming Soon!)</li> </ul>"},{"location":"guides/unity-guides/unity-guides-index/#c-scripting","title":"C# Scripting","text":"<ul> <li>C# Language Features</li> <li>Useful Visual Studio Functions (Coming Soon!)</li> </ul>"},{"location":"tutorials/tutorials-index/","title":"Tutorials","text":"<p>Tutorials are long-form, nearly step-by-step write ups that readers can follow to recreate a particular outcome, often for the purpose of learning as one follows along.</p> <p>Our First Steps guides on any particular tool are primarily for helping new developers get up to a good starting point from which they can branch out from. We would like to eventually have one for every popular game development tool!</p>"},{"location":"tutorials/tutorials-index/#unity","title":"Unity","text":"<ul> <li>Introduction to the Editor</li> <li>First Steps: Learn How to Use Unity!</li> <li>Fall 2024 Game Jam Template</li> </ul>"},{"location":"tutorials/tutorials-index/#game-engines","title":"Game Engines","text":"<ul> <li>Introduct to Game Engines</li> <li>Win32 Environment Setup</li> <li>Platform: Getting Start with Win32</li> </ul>"},{"location":"tutorials/game-engines/introduction-to-game-engines/","title":"Introduction To Game Engines","text":"<p>Written by Chris DeJong - 4/19/2023</p> <p>Modern game engines are designed to encompass every feature a game designer will need to create their games. They contain sound engines, lighting logic, animation editors, scripting engines, entity component systems, custom file I/O libraries, memory management utilities, multithreaded subsystems, and so much more. When we think of game engines, we often think of game engines like Unreal, Unity, and Game Maker.</p> <p>The editor of these game engines are what we imagine when we think of \"game engine\". However, it's important to step away from this line of thinking. You can think of this editor as \"tooling\", a subset among the many features that a game engine has to offer.</p> <p>At the simplest level, game engines are graphics renderers with interactive controls. By building a graphics renderer, you have effectively created a game engine--just add the human interactive components and you have yourself your own game engine! In fact, the human interactive component are one of the easier pieces to implement for any game engine.</p>"},{"location":"tutorials/game-engines/introduction-to-game-engines/#where-do-we-begin","title":"Where do we begin?","text":"<p>Suppose you ask yourself this simple question:</p> <p>How do I create a game engine?</p> <p>If you find yourself on Stack Overflow, Quora, or any Q/A website, then you might have saw an answer along the lines of:</p> <p>That would be too difficult. Why would you want to do that when \"X\" and \"Y\" already exist?</p> <p>This response is what stifles creativity and hinders exploration. We all want to learn how things work and just because it's hard doesn't mean we shouldn't try. It is true that game engines like Unity and Game Maker already exist, but that doesn't mean that learning how to make a game engine is a fruitless endeavor. I mean, let's be real, we're not going to compete with triple-A budget studios that created games engines like Unreal, but there is so much we can learn just by doing that long-term success is irrelevant.</p> <p>But this superimposes the idea that building a game engine is a venture that you won't complete. I promise you that's not true either. Knowing is half the battle. That's why it's so difficult to get started. Once you know what you're looking for, it's very easy to pave your own path and explore.</p> <p>By the end of these articles, you will have sufficiently learned enough about game engines to create a game from scratch. You will be surprised that there really isn't much to it. How far you want to go is what will end up determining how much work you will need to put in.</p>"},{"location":"tutorials/game-engines/introduction-to-game-engines/#prerequisites","title":"Prerequisites","text":""},{"location":"tutorials/game-engines/introduction-to-game-engines/#knowledge-prerequisites","title":"Knowledge Prerequisites","text":"<p>I will expect that the reader of these articles to have some familiarity with C/C++ programming. You should be able to write for-loops, while-loops, functions, and simple structs with competency. For NIU CSCI students, having completed CSCI 241 would make you well competent in these areas. For those who have not, but feel rehearsed enough in the above areas, please continue. No better way to learn than by practice.</p> <p>You should also be familiar with Windows. Some of you may be Mac users, so having some basic understanding of Windows will greatly aid you along the way. Being able to use Window's Terminal (Command Prompt or PowerShell) will be very useful in the long term.</p> <p>Lastly, you will need to know how to read API documentation. If you don't, then you will (need to) learn very quickly. I can not reasonably cover every detail there is about Win32 and OpenGL, so there will be moments where I will ask you to reach out to the documentation and piece out what it needs. Trust me, I won't make you do it for the very important stuff which deserves an explanation.</p>"},{"location":"tutorials/game-engines/introduction-to-game-engines/#software-prerequisites","title":"Software Prerequisites","text":"<p>You will need a small list of software to get started.</p> <ul> <li> <p>Microsoft Visual Studio</p> <p>Visual Studio contains the MSVC toolchain which will allow us to compile C/C++ code to our machine. Once installed, it will launch Visual Studio Installer, an update manager / plugin suite where you will select Desktop Development with C++. This will ensure that MSVC is included with your installation of Visual Studio. You can add other packages if you want, but we only need that one.</p> </li> <li> <p>CMake</p> <p>We will also want CMake. CMake is a set of tools that makes building binary projects easier. We will be using this to help generate our build files. In our case, it will be Visual Studio solution files. This isn't a hard and fast requirement; you can get away with just Visual Studio itself, but I highly recommend that you use CMake instead since it decouples your source files from the build tool (which would be Visual Studio/MSVC). We won't be interacting with CMake scripting much beyond writing our initial CMake script and maintaining the list of source files we compile within said script.</p> <p>Note: You will need to let CMake add itself to PATH for all users during installation to allow it to work via CLI since we will be using the CLI to configure and build our CMake scripts.</p> </li> <li> <p>Git</p> <p>If you don't already have Git installed, now is the time. You will want to use an online source tracking service like Github to manage your project. Whether or not it is public or private is up to you. This is a big project, so you want to keep your code from disappearing if the rocks in your PC no longer conduct lightning.</p> </li> <li> <p>Your Favorite Text Editor</p> <p>If you use CMake, you won't need to use Microsoft Visual Studio to write your code. I personally use Vim, others prefer VS Code. Use whatever editor you are the most comfortable with. (Microsoft Word, anyone?)</p> </li> </ul> System Prerequisites <p>You will need a computer running Windows 10 or Windows 11. You don't need a gaming PC or a high end laptop to do anything that we are about to do. I imagine even a ressurected fossil will be able to reliably run our application with minimal effort. However, to have full access to the suite of development tools that Microsoft provides us, having an up-to-date operating system is key to long-term success.</p>"},{"location":"tutorials/game-engines/introduction-to-game-engines/#code-style-over-optimization-and-object-orientated-programmingdesign","title":"Code Style, Over-Optimization, and Object-Orientated Programming/Design","text":"<p>Before I send you off to write code, let's take a brief moment to talk about the act of actually writing code. Throughout these articles, you will find that I am not using object-orientated programming for many of the problems that we are encountering. You are free to approach these problems with OOP if you so desire.</p>"},{"location":"tutorials/game-engines/introduction-to-game-engines/#over-optimization-and-you","title":"Over-Optimization and You","text":"<p>Let's talk about something fairly important: over-optimization. We want to write code that is both fast and easy to write, but rarely do these two things happen together. Throughout these articles, I will demonstrate code which is the easiest to write. Such code will probably stay the way it is for a significant amount of time, other times we will immediately refactor it to account for performance. It's easy to get carried away with your code and so the first key advice I have for you is to slow down.</p> <p>One of the best ways to approach any given problem, be it programming or in life, is to look at the problem with a \"first principles\" perspective. How would you solve this problem if you were told to do this using your gut instinct? Your solution need not be elegant, fast, or thought out. You might be surprised that simple solutions are often some of the best. Our goal is not to write the best code around, but to write code that gets us to step two, and then to step three, and so on.</p> <p>When performance problems arise, they stick out. That's when you optimize.</p>"},{"location":"tutorials/game-engines/introduction-to-game-engines/#defining-your-code-style","title":"Defining Your Code Style","text":"<p>I write code in a very particular way. I liken it more to C than to C++. For object composition, I use structs to handle my data arrangements. Sometimes, I use static globals. When I write functions, I write long bodies of code that could be reasonably decomposed into smaller functions. You could say that I break all the conventions of what \"clean code\" looks like.</p> <p>There are no rules to software development, my friends. If there were, my code wouldn't compile. My second bit of key advice to you is to find a code style that works best for you and stick with it. Do not change how you do things mid way through your project and refactor everything just to meet your new standards. If you absolutely must, don't refactor, just switch. I don't know of any code base that doesn't look like a nightmare after line 10,000. That is just what scale looks like.</p>"},{"location":"tutorials/game-engines/introduction-to-game-engines/#up-next-win32-environment-setup","title":"Up Next: Win32 Environment Setup","text":"<p>In the next article we will set up our development environment using CMake and get everything we need to start developing our game engine.</p> <p>Next: Win32 Environment Setup</p>"},{"location":"tutorials/game-engines/win32-environment-setup/","title":"Win32 Environment Setup","text":"<p>Written by Chris DeJong - 4/19/2023</p> <p>Before we can dive right in, there is some paper work to get out of the way. Fortunately, you will only ever need to do this once since you can easily copy over the structure to create a new project. It's quite handy if you want to develop in C++ on Windows.</p>"},{"location":"tutorials/game-engines/win32-environment-setup/#preparing-the-project-directory-source-folder-structure","title":"Preparing the Project Directory &amp; Source Folder Structure","text":"<p>We will begin by creating a folder in <code>C:\\</code> directory called <code>Development</code>. This will be where we will create our Win32 projects. In the <code>C:\\Development</code> directory, create a new directory with a name for your game engine API. Something catchy, preferably. In this folder, create another folder called <code>source</code>. Your project structure should end up looking similar to this:</p> <pre><code>C:\\Development\\my-project\\\nC:\\Development\\my-project\\source\n</code></pre> Other Directories <p>If you want to development somewhere else, that's fine too. We want a location that's easy to type an absolute path for, hence why I choose to develop at this particular location. This will become apparent down the line when we do some file I/O procedures. For now, we won't be using relative paths within our program until we examine what happens when we try to do so.</p> <p>From this point forward, any reference to the root directory of our project or some derivation of this statement will refer to <code>C:\\Development\\my-project</code>. I will also type out paths such as <code>./cmakelists.txt</code> or <code>./source/main.cpp</code> to refer to various files. Take special note here that I will always refer to the root directory in these instances to be explicity about the file I am referring to. You may want to adopt your own folder structure, so do your best to keep a mental map of the files as we go along.</p> <p>You now have the opportunity to initialize Git on your folder and connect it to a Github repository. Additionally, take the time to get your text editor set up and open. Once you're ready to pound out some text, create a new file in the root directory of your project called <code>cmakelists.txt</code>.</p>"},{"location":"tutorials/game-engines/win32-environment-setup/#preparing-cmake","title":"Preparing CMake","text":"<p>If you have never used CMake before, you can find a tutorial here for your personal reference. There are tons of ways to handle writing a CMake script, but for these tutorials, I will maintain a single CMake script in the root directory for the sake of simplicity.</p> <p>The below script is one that I use for all my projects. All I do is add source files within <code>add_executable(...)</code> as I make them. Be sure to change the name of <code>project()</code> to a name of your choice. This name will reflect the name of the executable, but you can change that under <code>add_executable</code> by replacing <code>${PROJECT_NAME}</code> to a string of your choice.</p> <pre><code># Initialize the CMake version\ncmake_minimum_required(VERSION 3.21)\n\n# Set the project name. Change this to the appropriate name as desired.\nproject(my-project)\n\nset(CMAKE_C_STANDARD 11)\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)\n\nadd_executable(${PROJECT_NAME} WIN32\n\n\"./source/main.cpp\"\n\n)\n\n# Search for OpenGL if we need it.\nfind_package(OpenGL REQUIRED)\n\n# Set Visual Studio's startup project to the base project.\nif (MSVC)\n    set_property(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT ${PROJECT_NAME})\nendif ()\n\n# Allow absolute referencing for project files located in ./src\ntarget_include_directories(${PROJECT_NAME} PUBLIC ./source)\n\n# Include OpenGL libraries.\ntarget_link_libraries(${PROJECT_NAME} opengl32.lib winmm.lib)\n</code></pre> <p>This CMake script also sets up a couple extra things we will need along the way.</p> <ol> <li> <p>We ensure that we have OpenGL and any Win32 libraries linked to our executable at compile time. Since we are not given these libraries by default, we need to link them ourselves.</p> </li> <li> <p>We also configure CMake to let us use angle bracket notation to access our header files. Rather than typing <code>#include \"main.h\"</code> or <code>#include \"../../core/my_header.h\"</code>, we can simply use <code>#include &lt;main.h&gt;</code> and <code>#include &lt;core/my_header.h&gt;</code> respectively. Neat.</p> </li> <li> <p>For sanity purposes, we force Visual Studio to generate a solution file with our project file as our default project when it loads. If you don't, it will get annoying fast.</p> </li> </ol>"},{"location":"tutorials/game-engines/win32-environment-setup/#preparing-an-entry-point","title":"Preparing an Entry Point","text":"<p>The last step in our setup is getting something to compile. Go ahead and create a file called <code>./source/main.cpp</code> and write a simple \"Hello, World\" program.</p> <pre><code>#include &lt;iostream&gt;\n\nint\nmain(int argc, char** argv)\n{\n    std::cout &lt;&lt; \"Hello, world\\n\";\n    return 0;\n}\n</code></pre> <p>From here, you will need to \"configure\" your CMake project by running this command at the root directory of your project:</p> <pre><code>cmake . -B./build\n</code></pre> <p>This command will create a folder called <code>./build</code> which contains everything MSVC needs to compile your project. You only need to run this command once to generate your project files. You may need to run this again if you change your CMakeLists file or delete the <code>./build</code> folder. If you encounter any weird errors while building (except for the one we are immediately about to see), 9 times out of 10, deleting the <code>./build</code> folder and reconfiguring your project will fix it. Additionally, you may want to create a <code>./.gitignore</code> file which excludes this directory since it can be generated on the fly fairly quickly.</p> <p>Now, to compile your program, you will once again use CMake by typing the command at the root directory of your project:</p> <pre><code>cmake --build ./build\n</code></pre> <p>This command will invoke MSVC on your project files. You will need to use this command every time to compile your project or go into your <code>./build</code> folder and open the Visual Studio solution file and compile through Visual Studio.</p> <p>If you did everything correctly, you probably got an error fairly close to this:</p> <pre><code>error LNK2019: unresolved external symbol WinMain referenced in function\n\"int __cdecl invoke_main(void)\"\n</code></pre>"},{"location":"tutorials/game-engines/win32-environment-setup/#up-next-getting-started-with-win32","title":"Up Next: Getting Started with Win32","text":"<p>In the next article, we will look at programming for Windows. We will look at the above error, how to correct it, and why it exists in the first place.</p> <p>Prev: Introduction to Game Engines</p> <p>Next: Platform: Getting Started with Win32</p>"},{"location":"tutorials/game-engines/platform/getting-started-with-win32/","title":"Getting Started with Win32","text":"<p>Written by Chris DeJong - 4/20/2023</p> <p>If you haven't followed the previous article yet, please do so now as it will get you caught up to speed on where we last left off. As a short recap, we setup our Win32 environment by creating a traditional \"Hello, World\" program, but encountered a strange error when compiling.</p>"},{"location":"tutorials/game-engines/platform/getting-started-with-win32/#the-entry-point","title":"The Entry Point","text":"<p>At some point during Microsoft's transition from MSDOS operating system to the current era of Windows we know it today, they made some decisions about how application types are handled at the kernel level. These early decisions meant that there is split between \"Console Sub-System\" applications and \"Windows Sub-System\" applications. When we create \"Windows Sub-System\" applications, Windows automatically provides us key libraries to interact with the kernel, but in turn strips us of the console under the expectation that we won't be needing it.</p> Could we re-hook a console? <p>You absolutely can, but not in the way you think. You see, Windows doesn't make this easy for us, so it is much easier to allocate a new console for us to perform standard input and output to. We will not be doing that for these articles because it won't be useful for what we're trying to do. In the rare instances we actually need a console, MSVC contains compiler intrinsics for us to use that integrate with Visual Studio which act as an interface for console output.</p> <p>I also don't want you to use the console as a crutch for debugging. Programming a game engine will get complex, so learning how to use Visual Studio to debug your program will be necessary down the line and, by forcing you to use it right out of the gate, it will teach you how to use it.</p>"},{"location":"tutorials/game-engines/platform/getting-started-with-win32/#transition-from-main-to-winmain","title":"Transition from Main to WinMain","text":"<p>In order to get our program to compile, we will need to define a new entry point called WinMain. You can think of WinMain as a \"higher order\" entry point with additional parameters that Windows provides us for interacting with the Win32 API. These parameters aren't going to be entirely important in the long run, but you can find information here:</p> <p>MSDN: WinMain, Application Entry Point</p> <p>MSDN: WinMain Documentation</p> <p>For now, let's just replace everything within <code>./source/main.cpp</code> with this:</p> <pre><code>#include &lt;windows.h&gt;\n\nint WINAPI\nwWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, int nCmdShow)\n{\n    return 0;\n}\n</code></pre>"},{"location":"tutorials/game-engines/platform/getting-started-with-win32/#compiling-with-winmain","title":"Compiling with WinMain","text":"<p>At this point, you should be able to correctly compile your program. As you might imagine, the program won't actually do anything, but let's run it anyway and see what happens. You will need to navigate to your <code>./build/bin/Debug/my-project.exe</code>. The name of the executable reflects what you set in the <code>./cmakelists.txt</code> file.</p> <p>Nothing will happen.</p> <p>Let's go back to <code>./source/main.cpp</code> and add a line within main:</p> <pre><code>...\nwWinMain(...)\n{\n    MessageBoxA(NULL, \"Hello, world\\n\", \"My Cool Message Box\", MB_OK);\n    return 0;\n}\n</code></pre> Regarding Code Snippets <p>I will be dropping code snippets with elipses <code>...</code>. This is not code, rather it is to indicate where code is. When we write large bodies of code, or add code to large bodies of code, I want to make it easy for you to find where exactly it is that I am adding the code, so I will copy a recognizable chunk and then omit portions to reduce the size of the snippet.</p> <p>In the above example, I leave an elipsis above <code>wWinMain</code> and between the brackets as <code>wWinMain(...)</code> to indicate that there is code there, but it isn't important for the code snippet.</p> <p>I will do my best to make it obvious where I am working and provide comments for the code that I am adding if it isn't clear in the snippet.</p> <p>When you compile this and attempt to run the application, you should get a pop up. Hit ok, the application will close.</p> <p>Congratulations! You have written your first Win32 program!</p>"},{"location":"tutorials/game-engines/platform/getting-started-with-win32/#up-next-creating-a-window","title":"Up Next: Creating a Window","text":"<p>In the next article, we will look at how to create a window with the Win32 API. By creating a window, it will be possible to blit pixels to the screen and, from there, flesh out a primitive drawing routine which will give us our first taste into software rendering.</p> <p>Prev: Win32 Environment Setup</p> <p>Next: Coming Soon!</p>"},{"location":"tutorials/unity-tutorials/unity-editor-introduction/","title":"Introduction to the Editor","text":"<p>By Jake Rogers</p>"},{"location":"tutorials/unity-tutorials/unity-editor-introduction/#introduction","title":"Introduction","text":"<p>This article will familiarize new Unity users with some important features of the editor.  </p> <p>The article is pretty much a written version of my YouTube video linked below, it is recommended to watch that to learn the editor, and use this article as a reference later.</p>"},{"location":"tutorials/unity-tutorials/unity-editor-introduction/#overview","title":"Overview","text":"<p>Upon opening Unity, you will be presented with the default layout of Unity's most important windows. Here is a brief breakdown of each window's function:</p> <ul> <li>Project<ul> <li>Shows you your project's file system rooted at the 'Assets' folder. More importantly, it allows you to create Unity specific files such as new materials, scenes, scripts, etc.</li> <li>Files here can be selected in order to edit them in the inspector (upcoming).</li> </ul> </li> <li> <p>Console</p> <ul> <li>Logs the INFO, WARN, and ERROR messages created by any script in your project. Think of it as where you would print \"Hello World!\" to in your first program.</li> <li>Most of the time (hopefully), this window will be empty while you are not in Play Mode, but it is possible to get console output while just using the Editor.</li> </ul> </li> <li> <p>Scene View</p> <ul> <li>Your view into your game's current scene as an editor, you can freely position the camera in this view.</li> <li>Compared to the game view, you will see gizmos and widgets in your game world, have the ability to enable special rendering modes (wireframe, unlit), and select GameObjects in the hierarchy by clicking on them.</li> </ul> </li> <li> <p>Game View</p> <ul> <li>This view (mostly) directly mimics what your scene looks like when in Play mode. You will see the scene through the perspective of the scene's main camera.</li> </ul> </li> <li> <p>Hierarchy</p> <ul> <li>This very important window shows you all of the GameObjects within the currently active scene, as well as presenting them in a hierarchical manner if any GameObjects are nested within each other (they won't be for a fresh project).</li> <li>From this window, GameObjects can be inspected, renamed, re-parented, and more.</li> </ul> </li> <li> <p>Inspector</p> <ul> <li>This window is your best friend. Any currently selected GameObject or file in the Project window will show up in the Inspector. From there, you will have the ability to edit all kinds of properties of the item, as well as the properties of components for GameObjects.</li> </ul> </li> </ul> More Windows <p>There are many, many more windows which can be spawned by using the Window dropdown at the top of the Editor, but they usually are not important enough to have docked at all times.</p>"},{"location":"tutorials/unity-tutorials/unity-editor-introduction/#editor-layouts","title":"Editor Layouts","text":"<p>The editor's layout can be re-organized in practically any way you desire. To do so, simply drag the tab representing the window to another location. You can split docks into two, tabulate them with other windows in a dock, or push them along the sides to create new docks. They can also of course be resized. Frankly, just try dragging a window all over the editor to see what options are available.</p>"},{"location":"tutorials/unity-tutorials/unity-editor-introduction/#save-layouts","title":"Save Layouts","text":"<p>If you change your layout from the default, it may reset back to the default the next time you open the editor. Therefore, you should save your current layout using the drop down in the top right.</p> <p>Keep in mind, you can save multiple layouts for different workflows- have a workflow completely dedicated to animation or compositing.</p> Tip <p>I personally find the default layout annoying, since you have to drag your mouse across the entire screen to go back and forth between the Hierarchy and the Inspector windows- something I do often.</p> <p>My 'Right-Heavy' layout moves the Hierarchy to be docked just left of the Inspector, which also gives me a nice and large dock for the Scene and Game views.</p> <p>Additionally, I often use Editor scripts which may print to the Console while I am in edit mode, so I split the Console and Project windows into two docks along the bottom so they are always open.</p> <p></p>"},{"location":"tutorials/unity-tutorials/unity-editor-introduction/#hierarchy","title":"Hierarchy","text":"<p>In order to explore the other windows in more detail, we should add some GameObjects to our scene! In general, we use the Hierarchy to do this.</p> <p>Right-click on any empty space within the Hierarchy to get a drop-down menu of new GameObjects you can create. Pick <code>3D Object -&gt; Plane</code>.</p> <p>A new GameObject \"Plane\" will appear at the bottom of your hierarchy. You may have also noticed the new geometry added in the scene view! Let's rename the plane to \"Ground\" by selecting it and pressing F2 to rename it.</p> <p>Well, you are basically a pro now. Try adding two new \"Cube\" objects and one new \"Cylinder\" to the hierarchy- they will also be in the <code>3D Object</code> section. Rename the Cubes to \"Bottom\" and \"Top\", and the Cylinder to \"Pillar\", and I will meet you over in the scene view!</p>"},{"location":"tutorials/unity-tutorials/unity-editor-introduction/#scene-view","title":"Scene View","text":""},{"location":"tutorials/unity-tutorials/unity-editor-introduction/#movement","title":"Movement","text":"<p>Now that we have some items in our scene view to give us a frame of reference, let's learn how to move our scene camera.</p> <ul> <li>Orbit<ul> <li>To Orbit the camera, hold down Alt, then click-drag your cursor along the scene view. This will spin your camera about an imaginary pivot some distance in front of you.</li> </ul> </li> <li> <p>Zoom</p> <ul> <li>To Zoom the camera, scroll your scroll wheel or hold down Alt and drag with the right mouse button.</li> <li>Note that zoom in will bring you closer to the \"imaginary pivot point\" in front of your camera, so you can only zoom in so far. Try zooming in very close and then orbiting if you are confused.</li> </ul> </li> <li> <p>Pan</p> <ul> <li>To Pan the camera, hold down the middle-mouse button and drag (You may have to hold Alt first, depending on your pointer device).</li> </ul> </li> <li> <p>Flythrough</p> <ul> <li>Flythrough allows you to navigate your scene with flight controls. To start flythrough mode, hold down right-click on your Scene View.<ul> <li>To move, use W, A, S, and D to move horizontally. Qq++ &amp; E can be used to move up or down relative to the camera.</li> <li>Hold Shift while moving like this to move faster.</li> <li>Move your mouse to change the orientation of the camera.</li> </ul> </li> </ul> </li> <li> <p>Focus</p> <ul> <li>When an item is selected in the Hierarchy, you can press F with your cursor over the Scene View to move your camera to the correct zoom and location to view the entire selected object.</li> <li>You can also do this by double-clicking any object in the Hierarchy.</li> <li>This is very useful if you have taken your camera on a while adventure and need to find your scene again!</li> </ul> </li> </ul> <p>Note that new GameObjects spawned in the Hierarchy will be initially created at your camera's pivot point, not at the scene origin (0, 0, 0).</p>"},{"location":"tutorials/unity-tutorials/unity-editor-introduction/#make-a-basic-scene","title":"Make a Basic Scene","text":"<p>Let's use those primative shape GameObjects we spawned in the Hierarchy to make a basic level.</p>"},{"location":"tutorials/unity-tutorials/unity-editor-introduction/#move-translation","title":"Move (Translation)","text":"<p>Your Scene View has a 'Tool Shelf' which gives you the ability to intuitively change a selected GameObject's Transform. Select the 'Move Tool', then select the \"Ground\" Plane.</p> <p></p> <p>If you cannot see your Ground plane, press F in the Scene View to focus the selected object. You should see a large, Red, Green, and Blue gizmo. Clicking and dragging on the Gizmo's handles will let you move the plane in the X, Y, and Z axis respectively. Give it a try.</p> <p>If you want some more control over your GameObject's transformations, take a look over on the Inspector window while it is selected. All GameObjects have a Transform component which dictates it's position within the scene (The Scene View tools are actually just tools for manipulating values in the Transform component!).</p> <p>You can type in exact values for your GameObject's Position, Rotation, and Scale here, which is very useful for making things line up perfectly.</p> <p>Traditionally, we like to keep our scenes centered around the origin point (0, 0, 0), so let's actually zero-out all the position elements in the Plane's Transform component.</p> Component Reset <p>You can clear out all Transform values by 'resetting' the Transform component.</p> <p>In fact, you can do this for any component. The reset option will set all properties to the component's default values.</p> <p></p>"},{"location":"tutorials/unity-tutorials/unity-editor-introduction/#scale","title":"Scale","text":"<p>We would like to make our Ground plane bigger, in the Scene View's Tool Shelf, select the 'Scale Tool', and some new Gizmos will appear on your selected object.</p> <p>Drag the red (X) and blue (Z) handles to make the plane a bit bigger. If you prefer typing in the values, set the X and Z Scale values of the plane to <code>2</code>.</p>"},{"location":"tutorials/unity-tutorials/unity-editor-introduction/#free-build","title":"Free Build","text":"<p>We have a nice Ground for a scene! Now, use the techniques listed above to position your two cubes and the cylinder in the scene.</p> <p>Make the 'Pillar' taller and a bit wider, and move it around so that it is resting just on top of the Ground plane (but not intersecting it).</p> <p>Make the 'Bottom' cube a bit wider (but not taller), and also bring it up to rest on the ground plane. Keep the 'Top' cube the same size, but position it on top of the 'Bottom' cube.</p>"},{"location":"tutorials/unity-tutorials/unity-editor-introduction/#rotation","title":"Rotation","text":"<p>Select the 'Top' cube and then select the 'Rotate Tool'. The gizmo for the rotate tool looks a bit more complicated, but it allows you to spin a GameObject in 3D space.</p> <p>Give the 'Top' cube a bit of Y-axis rotation (more formally known as 'X-Z' Plane rotation) by click-dragging your cursor along the green ring.</p> <p>The final result should look something like this (Ignore the colors, we'll get to that!)</p> <p></p>"},{"location":"tutorials/unity-tutorials/unity-editor-introduction/#add-some-color","title":"Add Some Color!","text":"<p>Lets add some color to our primitive shapes. In Unity, Materials are resources which describe how a 3D mesh should look when rendered to the screen, handling things like color, light reflectivity, special mapping, and other effects. We just need to create some materials that we can apply to our objects to give them different color.</p>"},{"location":"tutorials/unity-tutorials/unity-editor-introduction/#create-new-materials","title":"Create New Materials","text":"<p>Things like Materials are created view the Project Window. Right-Click on the 'Assets' folder and select <code>Create -&gt; Folder</code>, name that folder 'Materials'.</p> <p>Note that this folder doesn't need to be called 'Materials' to work properly, we are just keeping our file system neat. </p> <p>A new 'Materials' folder will be created, click on it to open the empty folder. In any empty space within it, Right-Click and select <code>Create -&gt; Material</code>. We will call our first Material 'Ground', then select it so it shows up in the Hierarchy.</p> <p>In brief, Materials allow the selection of special graphics programs called 'Shaders' which will determine how any mesh they are attached to should be rendered. </p> <p>The default <code>Universial Render Pipeline/Lit</code> shader is a general shader using Physically Based Render (PBR) techniques to enable some cool interactions with light. The parameters you see available in the Inspector are provided by the selected shader; an <code>Unlit</code> shader would just have a 'Base Map' parameter, for example.</p> <p>For this Ground material, we will select the Base Map and change it's color to a pure white. Click on the Color Bar and use the Color Wheel to do this.</p> <p></p> <p>Great! Before we apply these Materials, select the \"Ground\" material in the Project window and press <code>Ctrl+D</code> twice to duplicate two more materials. Call one of them 'Primary' and one of them 'Secondary'.</p> <p>For our purposes, we will need to create a new material per each color we would like to use in our scene. Change the Base Map of the Primary and Secondary materials to any two colors of your choosing. </p> <p>You can use the 'Outer Ring' of the Color Selector to change the hue of your color.</p>"},{"location":"tutorials/unity-tutorials/unity-editor-introduction/#apply-materials","title":"Apply Materials","text":"<p>We created materials, but we still need to apply them. You can drag-and-drop the material from your Project window onto the target GameObject in the Scene View or Hierarchy window to set their material.</p> <ol> <li>Apply the 'Ground' material to the Ground Plane</li> <li>Apply the 'Primary' material to the Top cube and the Pillar</li> <li>Apply the 'Secondary' material to the Bottom cube.</li> </ol> <p>Notice that we reused the Primary material on two different GameObjects? The neat thing about that is that if you go back and edit your Primary material, you will notice the changes update in real-time on both meshes!</p> <p>If you want, try messing around with the Metallic and Smoothness sliders on your materials to see how they effect them.</p>"},{"location":"tutorials/unity-tutorials/unity-editor-introduction/#conclusion","title":"Conclusion","text":"<p>You now have some basic knowledge of using the Unity editor to build a simple scene by learning the following:</p> <ul> <li>Using the Project window to manage and create new resources.</li> <li>Using the Hierarchy to create new GameObjects and meshes.</li> <li>Using the Inspector to edit GameObjects and Project resources.</li> <li>Navigating the Scene View and using Transform Tools to move GameObjects.</li> <li>Creating materials to change the way meshes are rendered.</li> </ul>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-first-step-index/","title":"Unity First Steps Series","text":""},{"location":"tutorials/unity-tutorials/first-step-series/unity-first-step-index/#introduction","title":"Introduction","text":"<p>Welcome to the Unity First Step Series! This is a collection of guides which will show you how to create a very basic game in Unity, starting from pre-installation.</p> Getting Your Feet Wet! <p>For an absolutely new beginner to game development, I highly recommend you take a detour to Unity's Roll-a-Ball tutorial project. It is a great first step for anyone's first game, and this guide will not be trying to reinvent that wheel.</p> <p>Roll-a-Ball Tutorial Project </p> <p>Instead, this tutorial will introduce you to some more intermediate techniques that will allow you to springboard into other more complex tutorials out there.</p> <p>Know how to program, but not familiar with C#? Read Unity's article on C# programming to get up to speed. It is pretty easier to learn if you are familiar with C++ or Java.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-first-step-index/#rocket-runner","title":"Rocket Runner","text":"<p> In the basic runner-style game you will be making, the player will constantly move forward while strafing horizontally to collect missile points and dodge hazards.</p> <p>Additionally, the player must collect enough missiles to be able to destroy kill-walls along their path, or their run will end.</p> <p>Later parts of this tutorial will act as modules, where we use the game as a basis to experiment with some more specific game development concepts.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-first-step-index/#index","title":"Index","text":"<ul> <li>Installing Unity</li> <li>Create a New Project</li> <li>Rocket Runner Base</li> </ul>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-first-step-install/","title":"Unity Installation","text":"<p>By Jake Rogers</p> <p>In this section, we will download Unity and some other necessary tools.</p> Warning <p>This guide is primarily tested on a Windows machine (10+). Mac or Linux users may have slightly different interfaces when installing Unity.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-first-step-install/#unity-hub","title":"Unity Hub","text":""},{"location":"tutorials/unity-tutorials/first-step-series/unity-first-step-install/#download","title":"Download","text":"<p>Unity Hub is a sort of 'launcher' for Unity. The application will allow you to download and manage multiple versions of Unity. It also allows you to create new projects and track existing ones, so you will use this app often to reopen your work!  </p> <p>Download Unity Hub</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-first-step-install/#unity-id","title":"Unity ID","text":"<p>In order to use Unity, you will need to make a Unity ID Account and log into it through Unity Hub.</p> <p>Create An Account</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-first-step-install/#unitys-licensing","title":"Unity's Licensing","text":"<p>Once your account is made, you may notice that Unity Hub is telling you that you need a license.</p> <p>In Unity Hub, open the drop down on the top left (next to the profile picture) and select 'manage licenses'. Select 'Add License' and get a personal one.</p> Unity Licenses <p>To paraphrase, Unity's Personal License permits you to create applications with Unity as long as your software(s) developed with Unity gross less than $200,000 in any fiscal year (The time between now and the last twelve months).</p> <p>The above only qualifies if you are an individual using Unity. If you are part of a legal entity or an established, budgeted organization / institution, the rules are different. </p> <p>Should you have the 'problem' of accidentally making over $200k in a fiscal year with your software, you (and your team) will need to upgrade to a Unity Plus or Pro license depending on your financial threshold.</p> <p>Unity's Terms of Service should be well-understood before creating a commercial product with the software. If in doubt, don't trust what I say, trust their terms of service!</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-first-step-install/#optional-create-an-organization","title":"(Optional) Create an Organization","text":"<p>At this point, you can also create a Unity 'Organization'. Organizations allow you to make use of some special Unity project services, such as advertising features or integrated source control like Plastic SCM.</p> <p>It is perfectly fine to make an organization with just you in it. In fact, one was created under the same name as your username when your first made a Unity ID. However, you can make a new org if you would like its name to be different from your Unity username, such as Jamie Doe Studios or Elder Oak Games.</p> <p>To do so, click on the drop down in the top left of Unity Hub, and select 'Manage Organizations'. Add a new one from the webpage it brings you to.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-first-step-install/#install-a-unity-editor","title":"Install A Unity Editor","text":"<p>Once you are signed in on Unity Hub and have acquired the appropriate license, you must install a version of Unity that you would like to use.</p> <p>Before continuing, consider changing your installs location in Unity Hub's preferences section. Preferably, change it somewhere on the fastest drive your system has, as this will substantially help your editor load faster.</p> <p>In Unity Hub, go to 'Installs', then select 'Install Editor'.</p> <p>For your own projects, you should pick the 'LTS' (Long-term support) version Unity recommends. However, this tutorial series uses version <code>2021.3.19f1</code></p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-first-step-install/#installation-modules","title":"Installation Modules","text":"<p>When installing a version of Unity, you will get the option of adding some additional modules.  </p> <p>Most importantly, you should select the provided version of Microsoft's Visual Studio Community. It is a very popular, free IDE for Unity which comes with some nicely integrated bells and whistles. This series and most other guides written by me will use it.</p> <p>Furthermore, you can also download build support packages which will give you the ability to build your final product on various platforms.</p> <p>These modules can be added to your installation later, so for now, just pick the support module for the platform you are developing on (Windows, Mac, Linux)</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-first-step-install/#optional-visual-studio-workloads","title":"(Optional) Visual Studio Workloads","text":"<p>If you decided to install Visual Studio Community, you will eventually be prompted to install some workloads. There is a specific workload for Unity, so pick that! You may also be interested in the Game Development with C++ workload, which has some features for Unreal Engine.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-first-step-install/#conclusion","title":"Conclusion","text":"<p>Once Unity Hub (and optionally Visual Studio Community) has finished installing, you are ready to move on to the next section! \\o/</p> <p>Next: Creating a New Project</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-first-step-new-proj/","title":"Create a New Unity Project","text":"<p>By Jake Rogers</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-first-step-new-proj/#introduction","title":"Introduction","text":"<p>After installing Unity, we can create a new project through Unity Hub. Let's make a new project for our runner game.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-first-step-new-proj/#project-creation-menu","title":"Project Creation Menu","text":"<p>In Unity Hub, click 'New Project' from the 'Projects' tab.</p> <p>At the top, you can select your installed editor version in case you have multiple installations. Pick the most recent LTS version.</p> <p>Unity comes with some templates for new projects you can select, each one giving you a clean slate or jumping-off-point for prototyping a particular type of game. </p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-first-step-new-proj/#pick-a-template","title":"Pick a Template","text":"<p>For our runner game, we will simply pick the 3D (URP) template.</p> <p>On the right side, pick a name for your project. I call the project Rocket Runner, but feel free to name it what you wish.</p> <p>You can also pick a directory (or file path) for your project. I recommend changing it to a fast drive on your system, such as an SSD or M.2 drive. Unity has a reputation for being quite hefty to load.</p> <p>When you're ready, press 'Create Project' and your project will be initialized for you. The first load will take a little bit longer than subsequent loads.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-first-step-new-proj/#conclusion","title":"Conclusion","text":"<p>You now have a new playground to mess around in, time to get to work! \\o/</p> <p>Now is a good time to view our article on acquainting yourself with the Unity Editor! Or, move straight into the runner game series.</p> <p>Recommended: Introduction to the Editor</p> <p>Next: Rocket Runner Part 1</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/","title":"Welcome to Rocket Runner!","text":"<p>By Jake Rogers</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#tutorial-video","title":"Tutorial Video","text":"<p>For those who prefer videos to textual guides, this guide will eventually have an accompanying YouTube video to follow along!</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#chapter-0-project-set-up","title":"Chapter 0: Project Set-Up","text":"<p>We created a project for this game in one of the previous steps in the series, but we still have some housekeeping to take care of now that we have dropped into the editor.</p> <ol> <li>Download and import the project assets.</li> <li>Enable the Unity Input System.</li> </ol>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#1-import-the-project-assets","title":"1) Import the Project Assets","text":"<p>We actually do not need many external assets here, but I have created a few so that we have something nicer to look at than some primitives.</p> <p>Download the Assets Here</p> <p>Inside the zip file you downloaded, there is a Models and Textures folder which you will need to move into your project's asset folder. You can do this by using your operating system's file browser, or by just dragging and dropping them into Unity's Project window. </p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#what-the-heck-is-this-stuff","title":"What the Heck is this Stuff?","text":"<p>The <code>Models</code> folder contains an FBX (3D model file) Octahedron I made, which is a useful shape for indicating direction. We will use it for both our player and our missile objects.</p> <p>The <code>Textures</code> folder contains a 128x128 grid texture which we will use for the ground, as it would be difficult to perceive movement against a ground with no texture. You may want to hang onto this texture, since it is a useful placeholder to have on hand in other projects.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#2-enable-the-unity-input-system","title":"2) Enable the Unity Input System","text":"Legacy Input System <p>By default, Unity projects come loaded with what is called the Legacy Input Manager, a system which Unity used to use to allow reading player input into game scripts.</p> <p>While it is still a fully servicable way to capture player input (and in many ways, easier to initially set up), 2019 brought forward the 1.0 release of the new Input System package. The Input System offers a significantly more sophistocated design for managing player input across multiple devices, processing player input, reading input events, and much more than can be explained here.</p> <p>The new Input System should be considered the 'canonical' way of capturing player input. Even though it is a bit tougher to learn, the greater degree of control will be of great use when you expand into bigger projects!</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#install-the-input-system-package","title":"Install the Input System Package","text":"<p>You can (and should) install the Input System package using the editor itself. Along the top, use the dropdown windows to select <code>Window &gt; Package Manager</code></p> <p>From there, switch the Packages displayed from <code>Packages: In Project</code> to <code>Packages: Unity Registry</code> to see packages available for download. Scroll down to the Input System, select it, and install.</p> <p>Once installation is complete, a dialog box will pop up informing you that Unity needs to be rebooted to enable the Input System backend, which you should do.</p> Input System Samples <p>Once rebooted, you can return to the package to download some Input System sample scenes, which can be useful for figuring out how to work with it in future projects. You do not have to do that for this guide.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#chapter-1-scene-groundwork","title":"Chapter 1: Scene Groundwork","text":"<p>Our game's environment will be a long road (going in the positive Z-axis direction) with two walls to keep the player in. That is easy enough to accomplish with a plane and two cubes!</p> <p>We will also construct our player in this stage as well.</p> <ol> <li>Create the Road</li> <li>Create the Player</li> <li>Apply Materials</li> </ol>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#1-create-the-road","title":"1) Create the Road","text":"<p> In the Hierarchy Window, right-click on any empty space and create a plane (<code>3D Object &gt; Plane</code>) and one cube (<code>3D Object &gt; Cube</code>).</p> <p>Select the two objects and reset their positions to <code>(0, 0, 0)</code> if they aren't already.</p> <p>To make our road, we will resize the plane by setting its scale to <code>(1.5, 1.0, 10)</code>. This will make our road a bit wider and much longer in the Z-Axis. Rename the Plane to Ground.</p> <p>We want to create 'railings' along our road which will stop the player from going off of it- our cube will serve this purpose. Resize it to be the same length as the ground by setting its Z scale to 100*. Also make the cube wider by changing its X scale to 2.</p> <p>* Note that the Plane primitive actually has a default size of 10 meters by 10 meters, and scaling it by 10 in the Z-Axis stretches it to 100 meters. This is why the cube must be resized to 100 and not 10, because the Cube is unitary (One meter cubed).</p> <p>We will need to move the cube to block the edges of the plane, so change its position to be <code>(8.5, 0.5, 0)</code>. Rename the cube to Right Wall</p> <p>We also, of course, need a left wall. Make life easier for yourself by duplicating the right wall! Select the Right Wall and press Ctrl+D to duplicate the GameObject. Then, change the new wall's X Position to <code>-8.5</code>, and rename it to Left Wall.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#grouping","title":"Grouping","text":"<p>These three GameObjects make up our road. Since we realistically always want them to keep their positions and scales relative to eachother, we should 'group' them together by making them siblings of one GameObject.</p> <p>Right-Click on the Hierarchy and select <code>Create Empty</code>, and rename the newly created GameObject to Road (Be sure to set its location to (0,0,0) if necessary) Select the Ground, Right Wall, and Left Wall and drag-and-drop them on top of the Road to make them children of that GameObject.</p> <p></p> <p>Now, if you select the Road object and move it, you will see all of its children move together with it! The Hierarchy also allows you to fold away children, which helps de-clutter the Hierarchy.</p> <p>In fact, let's move the road forward on the Z-Axis by 45, since we want the start of the road to be near the origin point.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#2-create-the-player","title":"2) Create the Player","text":"<p>Let's get started on our player. As a reminder, they will be a small Octohedron floating a bit off the ground, traveling forward in the Z-Axis.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#player-model","title":"Player Model","text":"<p>Start by creating an empty GameObject at the scene origin (0, 0, 0) and name it Player. Then, create a new empty GameObject as a child of the Player called Player GFX (Player Graphics).</p> <p>In your Project window, navigate to the Models folder and drag-and-drop the Octohedron.fbx file onto the Player GFX object. You should see a rather large model appear. Select the newly created Octohedron model and scale it down to a more reasonable size, like <code>(0.4, 0.4, 0.4)</code>.</p> <p>As mentioned previously, we want the player to look like they are floating, select Player GFX and move its Y Position up. <code>1.2</code> is a good number.</p> <p></p> Why Are we Doing it This Way? <p>You may be wondering why we have chosen to structure our player this way. Why not just use the Octohedron as our player root, for example? There is no immediate reason why you cannot do this, but it will bite you in the future.</p> <p>For starters, many complex GameObjects will often need to consist of multiple GameObjects rooted under the same parent (similar to the Road we made earlier). Since children inherit their parent's Transforms (positions, rotations, and scales), we want to try and separate the hierarchy of unrelated items in our object as best as possible.</p> <p>For example, later we will make our Octohedron model spin as it flies through the level. If we had everything parented to our Octohedron model, it would make everything on the player spin, which would be a huge mess!</p> <p>Therefore, we create a GameObject specifically for the player's graphical representation, and put the Octohedron under that. By then moving the GFX up a bit, we move the model up as well. That way, any other graphical objects we have will all be vertically aligned, and our Octohedron can spin without any side effects.</p> <p>Further, the position of the top-most GameObject in any group is often considered that collective object's 'True Position'. It is also often a useful notion and standard to have an object's position be at ground-level directly below its center of mass.</p> <p>Our player is represented by a the Octohedron, but we would like its position to be described as somewhere along the X-Z plane, and the Y position is always 0 for simplicity's sake. So we keep the root GameObject at Y=0, but move the graphical representation of the player up a bit.</p> <p>The benefits of this are a bit difficult to conceptualize out of context, but it will make more sense as we develop our player object (and as you make some inevitable mistakes in your own projects!). The way you organize and object's sub-hierarchy is very important when you start creating more complex things!</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#3-apply-materials","title":"3) Apply Materials","text":"<p>Just like we did in the editor introduction, we will add some color to our scene by creating and applying some materials.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#add-some-color","title":"Add some color","text":"<p>Since this is already explained in Introduction to the Editor, we will be brief here.</p> <p>Create a <code>Materials</code> folder and add three materials, Ground, Wall, and Player and apply them to their respective objects by drag-and-dropping in the Scene window. I personally used a light-cyan for the ground, a dark blue for the walls, and a magenta for the player.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#grid-texture","title":"Grid Texture","text":"<p>Ah, but I mentioned we had a texture for the ground, let's add this now! Textures need to be added to 3D objects through materials, so select your Ground material. On its Base Map property which you used to change its color, click on the selector button (a circle with a dot in the middle) and search for then pick the <code>Grid-sprite</code> texture.</p> <p>The result that you get from doing this is... Not quite right. The texture is there, but it is stretched across the entire road! We were hoping to get a repeating 'tiled' texture.</p> <p>This is easy to fix. Lower down in the material properties, change the Tiling settings to <code>X: 3, Y: 20</code>. This basically tells the shader that it should make the texture 3 times smaller in the X direction, 20 times smaller in the Y, and then repeat the texture to compensate. This resizes the texture to be 1:1 in scale tiled across the plane.</p> <p>The numbers 3 and 20 are picked because the scale of our plane is <code>(1.5, 1, 10)</code>- we use the scale numbers then multiply by two to account for the length in both directions (Z translates to Y when it comes to the texture).</p> <p>Your scene should look something similar to the following: </p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#chapter-2-player-locomotion","title":"Chapter 2: Player Locomotion","text":"<p>We are ready to get our player moving! As previously mentioned, our player should constantly move forward down the road (positive Z)- they will have no control over that. They, however, will also be able to strafe left and right to control their position on the road (X axis), which will involve player input.</p> <p>Additionally, we want our player to collide with the walls of the road so they cannot escape, and we will need to come up with some solution to have our camera follow the player as they sail off into the distance.</p> <ol> <li>Set Up Physics for the Player</li> <li>Moving Forwards</li> <li>Bring the Camera With!</li> <li>Player Actions</li> <li>Strafing</li> </ol>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#1-set-up-physics-for-the-player","title":"1) Set Up Physics For the Player","text":"<p>As mentioned above, we need our player to collide with various objects throughout the scene to keep them in the playable space and for other purposes later. Of course, collision detection in 3D space is not a trivial matter, so we will use Unity's Physics to handle detection for us.</p> <p>However, the movement of our player is not going to be physically simulated- in fact, we want the player to have tight control over their character, so we will be foregoing drag simulations, inertia, mass, etc., we only want collision.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#rigidbody-component","title":"Rigidbody Component","text":"<p>Select the Player GameObject and, using the Inspector, do <code>Add Component &gt; Rigidbody</code> by using the button at the bottom of the Inspector. Rigidbodies also need a collider component somewhere on the same GameObject or a GameObject in its children.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#add-a-collider","title":"Add a Collider","text":"Where Does Our Collider Go? <p>Colliders dictate the physical space an object takes up within the Physics system, and are used for detecting collisions. Question is, which GameObject should we put our collider on?</p> <p>The obvious answer is on the Octohedron model. After all, the player's collision ought to most closely resemble the player's graphical representation, right? That is reasonable, but in the future, we may want our player's model to rotate or move up and down for special effects, and we don't want to be radically changing the player's collision boundaries when we do that.</p> <p>Imagine if our player was trying to navigate a very narrow corridor, and all of a sudden one of our graphical effects caused the Octohedron to spin sideways, which then collided them with a wall and forced them to fail.</p> <p>No, we want to have collision without locking ourselves out of being able transform the player model. Realistically, we only want to designate an abstract space in the middle of the player which is used for collision detection- a 'hitbox' so to speak. Therefore, let's attach our collider to the Player root object. That way, we don't have to worry about any changes to our graphics objects affecting our collisions.</p> <p>Select the Player and do <code>Add Component &gt; Box Collider</code> from the Inspector. You should now see a green box in the scene for the player. Using the settings on the Box Collider component, we can adjust its size and center to vaguely wrap it around the Octohedron's normal position. The 'Edit Collider' toggle button allows you to use Gizmos to adjust it in the Scene view, which is highly recommended.</p> <p>Position and size your box collider to the approximate size of the Octohedron, and drag the bottom side down a bit so it can collide with the walls better.</p> Collider Size <p>Protip: make the X &amp; Z size of the collider slightly smaller than the actual Octohedron. As it turns out, your game will often feel better if the player's collision is a tad smaller than it seems it should be. Perfectly accurate colliders make it feel like you are \"getting caught\" on things all the time, and smaller colliders let players feel like they are narrowly dodging around things all the time.</p> <p></p> <p>Here is my collider's configuration. Notice it extends a bit lower so we can get good contact with the walls, and it doesn't fuller enclose the actual model. You can copy my <code>Center</code> and <code>Size</code> settings if you are having difficulty getting yours right.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#rigidbody-configuration","title":"Rigidbody Configuration","text":"<p>Returning back to the Rigidbody component, our player now has physics. In fact, if you were to raise it a bit higher up and enter play mode, you would see it fall to the ground. </p> <p>We need to make a few changes to prevent the physics system from making unwanted displacements on our Player:</p> <ol> <li>Change the <code>Mass</code> to some large number, like <code>999999</code>. This will allow our Player to push dynamic physics objects out of its way if necessary.</li> <li>Disable <code>Use Gravity</code>. We do not desire any downwards velocity right now.</li> <li>Change the <code>Collision Detection</code> mode from <code>Discrete</code> to <code>Continuous Speculative</code>. This gives our rigidbody a more reliable high-speed collision detection solution at a minor increase to computation. It should eliminate the possibility of tunneling through obstacles at high speed.</li> <li>Fold out the <code>Constraints</code> property and freeze the Y position and all rotation axes. Again, our game does not make use of the vertical Y-Axis for now, so we will just lock that position. We also don't want our Player to start spinning from any applied forces.</li> </ol>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#2-moving-forwards","title":"2) Moving Forwards","text":"<p>It is not too difficult to get our player moving constantly forward, but we will need to use a script to drive this motion!</p> <p>In your Project window, create a new folder <code>Scripts</code>. In that folder, Right-click for <code>Create &gt; C# Script</code>. Name the script <code>PlayerMovement</code>.</p> PlayerMovement.cs<pre><code>using UnityEngine;\n\n[RequireComponent(typeof(PlayerMovement))]\npublic class PlayerMovement : MonoBehaviour\n{\n    private Rigidbody _rigidbody;\n\n    private void Awake()\n    {\n        _rigidbody = GetComponent&lt;Rigidbody&gt;();\n    }\n\n    private void FixedUpdate()\n    {\n        Vector3 newPosition = _rigidbody.position;   // Get the current position...\n        newPosition += Vector3.forward;             // Add (0, 0, 1) to the newPosition in order to move it forward.\n\n        _rigidbody.MovePosition(newPosition);\n    }\n}\n</code></pre> Abstract <p>This script is pretty simple. In the Awake method (called when the object is first loaded in, but before any update calls), we get a reference to the rigidbody component attached to the same GameObject as the script- the one for our player.</p> <p>In the FixedUpdate call, which occurs whenever a physics update occurs, we will take our current position, increment it by one in the z-axis, and move our rigidbody to the incremented position. Note that for the most part, any logic which involves calls or accesses to rigidbody components should always occur within the FixedUpdate call so that it can properly interact with other physics objects!</p> <p>Did you notice the <code>RequireComponent</code> attribute above the class definition? When you specify required components on a MonoBehavior class, it tells Unity that your script should always be paired with a component of that type when attached to a GameObject. This prevents our call on line 10 from ever returning null and crashing our script.</p> <p>Save the script. Back in the editor, select the Player and <code>Add Component &gt; PlayerMovement</code>, then enter Play Mode, you will notice your player zoom off!</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#3-bring-the-camera-with","title":"3) Bring the Camera With!","text":"<p>Obviously, we want to have our camera keep pace with the player!</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#a-bad-solution","title":"A Bad Solution","text":"<p>An easy but bad way to accomplish this would be to just make the Main Camera a child of the Player GameObject, then offset it to a nice angle. However, this has two rather cumbersome side effects:</p> <ol> <li>Parenting cameras directly to physics objects is janky. While it may or may not manifest itself here, it is possible to get some strange, jitter-type artifacts when you do this, so it is generally not great to have the camera be moving in association with the FixedUpdate loop.</li> <li>This makes the Player 'responsible' for the Main Camera. From a design sense, we would like to decouple things as much as possible. In a practical sense, it means our player will need to constantly compensate for the camera. For example, if we delete the Player GameObject, we will need to detach the camera first or else our game will plunge into darkness with it (this is bad).</li> </ol>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#a-good-solution-follow-script","title":"A Good Solution (Follow Script)","text":"<p>A better solution is to allow the camera to handle its own movement by feeding it an object to follow. This not only allows us to follow the player with low coupling, it also gives us some wiggle room to potentially have the camera look at other targets.</p> <p>Essentially, we shall create a Script to move the camera around as though it were being held by an extremely diligent camera operator.</p> <p>Create a new script, name it <code>CameraRig</code></p> CameraRig.cs<pre><code>using UnityEngine;\n\npublic class CameraRig : MonoBehaviour\n{\n    public Transform FollowTarget;      // The transform this camera will follow\n    [SerializeField] private Vector3 _followOffset = Vector3.zero;  // The local position that FollowTarget is followed from.\n    [SerializeField] private bool _useAwakeOffset = true;   // Should the _followOffset be determined by my global position on awake?\n\n    private void Awake()\n    {\n        if (_useAwakeOffset)\n        {\n            _followOffset = transform.position;\n        }\n    }\n\n    private void LateUpdate()\n    {\n        if (FollowTarget != null)\n            transform.position = FollowTarget.position + _followOffset;\n    }\n}\n</code></pre> Abstract <p>Again, fairly simple. Note that the <code>SerializeField</code> attribute is being used to allow private-scoped variables to show up in the inspector- a useful trick if you want to populate script parameters without exposing their scope.</p> <p>The option to set our <code>_followOffset</code> in the awake method is nice, since it lets us use the Scene view to pick a nice camera angle.</p> <p>Note that we use the <code>LateUpdate</code> method to change our camera's position. The <code>LateUpdate</code> tick always occurs after that of <code>Update</code> and <code>FixedUpdate</code> (If one occurs that frame), but just before the frame is written to the screen. This makes it a good time to reposition our camera so it has the most up-to-date position.</p> Info <p>If our script changed the position of the camera in the regular <code>Update</code> tick, it is possible that something else could change the Player's position before the screen write, which would result is small inaccuracies. Small inaccuracies on the player's camera produce very ugly jitter, so try to avoid them.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#apply-the-new-script","title":"Apply the New Script","text":"<p>We will not actually apply this script directly to the camera. Instead, we will create a Camera Rig object, put the script on it, then make the Main Camera a child of that. You can do this easily by right-clicking the Main Camera and picking <code>Create Empty Parent</code>, then add the new script to the object.</p> Inspector-Assigned Properties <p>Whenever we create a public or SerializedField member in one of our scripts and it is not assigned to through the code, we are usually expecting to manually assign something to that property per instance using the Inspector.</p> <p>In this circumstance, we want to drag-and-drop the Player GameObject (and thusly, its transform) into the <code>Follow Target</code> property to specify what the camera will follow.</p> <p>Forgetting to assign your properties can lead to null reference exceptions!</p> <p>Ensure that our <code>Use Awake Offset</code> flag is on, and position the Camera Rig at a nice position to view the Player and the upcoming road. You will want to rotate the camera on the X-axis a bit to get a downward view- it is probably better to apply that rotation to the Main Camera itself.</p> <p> I put my Camera Rig at <code>(0, 10, -12)</code> and set the X-axis rotaton of the Main Camera to 23 degrees. I also changed the FOV of the Main Camera to 52 degrees to get a nice view.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#4-player-actions","title":"4) Player Actions","text":"<p>We need to improve our <code>PlayerMovement</code> script to allow the player to strafe left and right. Before that, we must create an Input Actions asset- a map of accepted Player Inputs to action events which we can hook our scripts into.</p> <p>If you wanted to create a new Input Actions asset (we do not), one can be created in the Project window by doing <code>Create &gt; Input Actions</code>.</p> <p>Instead, we can actually trick Unity into giving us a pretty competent default. On your Player object, add a <code>Player Input</code> component. You will see a small message box in the Player Input component informing you that no Input Actions exist, select \"Create Actions...\". The default name is fine here.</p> <p>Input Actions asset was created in your <code>Assets</code> directory. Double-click it in the Project window to pull it open. You will see it has created two Action Maps (different controls for different contexts), select the Player one.</p> <p>By default we were given some Actions for Moving, Looking, and Firing, of which we will only use one (There is little harm in keeping the others, hang onto them in case you wish to expand this project in the future). Expand out the Move Action.</p> <p></p> <p>Each Action (green) is composed of a Binding (blue), which may be composited (purple) from a few inputs. Giving an action multiple bindings is great for allowing the same action to be expressed by more than one input device. By default, our Move action can be inputted via the Keyboard WASD or arrow keys, a gamepad stick, a VR controller, and even a joystick!</p> <p>We could definitely spend much longer than necessary here detailing the Input System. For now, select the WASD binding and change its Mode from <code>Digital Normalized</code> to <code>Digital</code>. Since we only plan on using the horizontal axis of the Move input vector, we do not care about normalizing the value. Be sure to hit the <code>Save Asset</code> button- it will not auto save for you.</p> <p>Make some time to read some dedicated articles about the Unity Input System. It has a learning curve, but it is very powerful, and you will make some progress after some frustrating trial and error.</p> <p>Recommended Reading: Game Dev Beginner's \"Input In Unity Made Easy\"</p> <p>If you created the Input Action asset via the Player Input component as we did, the component's <code>Actions</code> parameter should already be populated. If not, select the one we just made now.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#5-strafing","title":"5) Strafing","text":"<p>Now that we prepped our user input, we can upgrade our <code>PlayerMovement</code> script to allow the player to move left and right.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#strafe-movement","title":"Strafe Movement","text":"<p>Simply enough, when we are in the process of calculating the next position of our player on any given frame, we should also add an offset on the X axis.</p> PlayerMovement.cs<pre><code>using UnityEngine;\nusing UnityEngine.InputSystem;\n\npublic class PlayerMovement : MonoBehaviour\n{\n    private Rigidbody _rigidbody;\n\n    private float _strafeInput = 0f;\n\n    private void Awake()\n    {\n        _rigidbody = GetComponent&lt;Rigidbody&gt;();\n    }\n\n    private void FixedUpdate()\n    {\n        Vector3 positionOffset = Vector3.zero;\n        positionOffset += Vector3.forward;             // Add (0, 0, 1) to the newPosition in order to move it forward.\n        positionOffset.x += _strafeInput;              // Add player's horizontal input to X. 1 if right, -1 if left.\n\n        _rigidbody.MovePosition(_rigidbody.position + positionOffset);\n    }\n\n    private void OnMove(InputValue inputValue)\n    {\n        _strafeInput = inputValue.Get&lt;Vector2&gt;().x;\n    }\n}\n</code></pre> Abstract <p>Whenever the PlayerInput component on our Player GameObject sees receives an event from the player performing an input, it will broadcast a message to any script on its GameObject. By giving our <code>PlayerMovement</code> script a method for <code>void OnMove(InputValue)</code>, we can tell our script to react to the player updating their movement inputs.</p> <p>In this circumstance, we just want to read in the value of the player's horizontal input to a stored variable. Note that we need to add <code>using UnityEngine.InputSystem</code> for the <code>InputValue</code> object.</p> <p>We also slightly change the way that we calculate the new position. Instead, we compute an offset which is then added to the rigidbody's position in the <code>MovePosition</code> call. This will be a better-expressed approach for when we add speed control.</p> <p><code>_strafeInput</code>, then, will be equal to -1 if the player inputs left, 1 if right, and 0 when nothing is held. From there, we add their input to the <code>newPosition.x</code> in order to apply some horizontal velocity for each frame!</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#speed-adjustment","title":"Speed Adjustment","text":"<p>Let's consider for a second- how actually fast is our player moving? Well, all of our logic for moving the player forward is being incremented in the <code>FixedUpdate</code> method. As the name suggests, this method is called at very exact, fixed intervals: exactly every 0.02 seconds by default, or 50 times a second. </p> <p>This means that our player has a forward speed of 50 units (meters) per second. This is very awkward, since it is way too fast and we would have to use small multipliers to slow it down.</p> <p>To account for this, we should multiply our per-update offset to be one-unit per second, which we can do by just multiplying the whole thing by that fixed update interval, which Unity happens to keep in a variable at <code>Time.fixedDeltaTime</code>.</p> PlayerMovement.cs (frag)<pre><code>private void FixedUpdate()\n    {\n        Vector3 positionOffset = Vector3.zero;\n        positionOffset += Vector3.forward;             // Add (0, 0, 1) to the newPosition in order to move it forward.\n        positionOffset.x += _strafeInput;              // Add player's horizontal input to X. 1 if right, -1 if left.\n\n        positionOffset *= Time.fixedDeltaTime;\n\n        _rigidbody.MovePosition(_rigidbody.position + positionOffset);\n    }\n</code></pre> <p>After making this change, you will notice that your player now moves at exactly one meter per second forward- very slow, but it gives us a good platform to multiply by integers and get a predictable speed.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#variable-speed","title":"Variable Speed","text":"<p>By using some <code>[SerializeField]</code>-tagged fields, we can apply some multipliers to the forward and horizontal contributions to our <code>positionOffsets</code> and produce different speeds.</p> PlayerMovement.cs (frag)<pre><code>...\npublic class PlayerMovement : MonoBehaviour\n{\n    [SerializeField] private float _forwardSpeed = 16f;\n    [SerializeField] private float _strafeSpeed = 10f;\n\n    private Rigidbody _rigidbody;\n...\n\n    private void FixedUpdate()\n    {\n        Vector3 positionOffset = Vector3.zero;\n        positionOffset += Vector3.forward * _forwardSpeed;             // Add (0, 0, 1) to the newPosition in order to move it forward.\n        positionOffset.x += _strafeInput * _strafeSpeed;              // Add player's horizontal input to X. 1 if right, -1 if left.\n\n        //positionOffset *= Time.fixedDeltaTime;\n\n        _rigidbody.MovePosition(_rigidbody.position + positionOffset);\n    }\n...\n</code></pre> <p>In the Inspector, you should now be able to modify the <code>_forwardSpeed</code> and <code>_strafeSpeed</code> to get different respective speeds!</p> <p>Since we did the groundwork of multiplying it against a unit-per-second speed, the resultant speed will be in X-meters-per-second. We ALSO know that a single segment of our road is 100 meters long, so each road segment will provide 100/X seconds of gameplay. Knowing how long it takes for a player to traverse your levels is useful to keep in mind when designing your game's content. Pretty neat!</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#chapter-3-points","title":"Chapter 3: Points","text":"<p>In our game, the player will need to collect points which, in turn, will give them missiles. In order to destroy Kill Walls which occasionally show up with increasing levels of hitpoints, they will need to have collected enough points or else they will run into the wall and lose.</p> <p>So, in this chapter we will create some pickups which will eventually spawn missiles for the player to hang onto for the next chapters!</p> <ol> <li>Create Point Pickup Objects</li> <li>PointPickUp.cs Script</li> <li>Spruce Up the Pick Ups</li> </ol>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#1-create-point-pickup-objects","title":"1) Create Point Pickup Objects","text":"<p>This will be a pretty simple GameObject, we will use a sphere to represent the PickUp, and a large trigger collider to describe how close the Player must be to collect it.</p> <p>In your Hierarchy, create a new empty GameObject and name it Point PickUp. Then, create a Sphere object as a child of it.</p> <p>On that Sphere child, remove it's Sphere Collider, we will be making one on the parent object.</p> <p>On the Point PickUp GameObject, <code>Add Component &gt; Sphere Collider</code>. This Sphere Collider will be the volume the Player must enter in order to collect the PickUp.</p> <p>On the collider, enable the <code>Is Trigger</code> property. This will stop the collider from registering collections on rigidbodies, but still allow it to detect collisions that we can hook into from our scripts.</p> <p>We will also make this trigger larger than the Pick Up's visual representation so that the player doesn't need to precisely collide with it. I changed the radius to <code>3.5</code>.</p> <p></p> <p>Position the pick up somewhere along and above your road- I put mine at a height of <code>Y = 2</code>. Also, make a material for this pick up to give it some color! I chose to make mine yellow with a tiny bit of metallic <code>Metallic Map = 0.37</code>.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#2-pointpickupcs-script","title":"2) PointPickUp.cs Script","text":"<p>This is going to sound strange, but before we work on this script, we need to at least create the <code>PlayerMissiles.cs</code> script and put it on our Player, it will make sense in a moment.</p> <p>Just like before, create a new script called <code>PlayerMissiles.cs</code>, as well as <code>PointPickUp.cs</code>. On the Player GameObject, <code>Add Component &gt; PlayerMissiles</code>. We will code this script later.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#scripting","title":"Scripting","text":"<p>On the Point PickUp GameObject, <code>Add Component &gt; PointPickUp</code> and open it for editting.</p> <p>This script will be set up to watch for any GameObject with specifically a PlayerMissile component to enter its trigger boundary. When that occurs, the PickUp will tell said PlayerMissile script to increment its points by one, then the PickUp should disappear.</p> PointPickUp.cs<pre><code>using UnityEngine;\n\npublic class PointPickUp : MonoBehaviour\n{\n    [SerializeField] private int _pointValue = 1;\n\n    private void CollectPoint(PlayerMissiles playerMissiles)\n    {\n        Debug.Log(\"I have been collected!\");\n        // TODO: Add a point to playerMissiles.\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        // Try to find PlayerMissiles Component on entering GO.\n        PlayerMissiles playerCheck = other.GetComponent&lt;PlayerMissiles&gt;();\n\n        // If component was found...\n        if (playerCheck != null)\n        {\n            CollectPoint(playerCheck);  // Collect the point.\n        }\n    }\n}\n</code></pre> Abstract <p>The <code>OnTriggerEnter</code> method is called during the <code>FixedUpdate</code> call when something enters the trigger collider on the same GameObject as the script. The <code>Collider other</code> is a reference to the collider component which invoked the collision.</p> <p>From the collider, we can query its GameObject for other components by using <code>GetComponent&lt;type&gt;</code>, so we check to see if the incoming object has a <code>PlayerMissiles</code> component, and run a routine for collecting the point if it does.</p> <p>It is very important that we verify the incoming collision does actually contain a <code>PlayerMissiles</code> component. <code>GetComponent</code> can return <code>NULL</code> if no component of the specified type is found on <code>other</code>, which would then trigger a <code>NullReferenceException</code> if we tried to invoke methods on it! Remember that any GameObject with a collider on it could invoke the <code>OnTriggerEnter</code> method by simply moving into its bounds- we want to filter to only those with <code>PlayerMissiles</code> scripts (one, in our case- the Player!).</p> <p>Since our <code>PlayerMissiles</code> script does not yet have a method for receiving points, we will write ourselves a note to implement that later.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#prefabs","title":"Prefabs","text":"<p>We are going to want to have multiple copies of these pick-ups, but we want them to all generally operate the same way with similar parameters. This makes them a good candidate to turn into a prefab.</p> <p>Prefabs are GameObjects which are saved somewhere in your Assets folder. Copies of the prefab can be instantiated into the scene which will inherit all of the properties and structure of the prefab. Additionally, if you make any changes to a prefab, all of the instances of that prefab in any scene are updated to match. This obviously makes them very powerful for reuse.</p> <p>In your Project window, <code>Create &gt; Folder</code>, name the folder Prefabs, and open it. Then, drag-and-drop the Point PickUp GameObject from the hierarchy into the empty space in the Prefabs folder. You should then see the new Prefab appear in the Project window and the Point PickUp GameObject in the Hierarchy should turn blue to indicate it is an instance of a prefab.</p> <p></p> <p>Now, try creating some new instances by drag-and-dropping from the Project window or <code>Ctrl+D</code> on the existing instance, and arrange the pick ups in a line.</p> Prefab Editor <p>IMPORTANT: When you want to make a change to a prefab that effects all instances, you should double-click it in the Project window to open the prefab editor. This will properly propagate all changes to any instances.</p> <p>If you do want a change on an instance of a prefab to propagate to all other instances, you can use the overrides drop down in the Inspector to do so, but this may have unexpected behavior. Therefore, it is always best to use the prefab editor to edit prefabs.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#3-spruce-up-the-pick-ups","title":"3) Spruce Up the Pick Ups","text":"<p>Now normally, it is not a great idea to invest a bunch of time polishing individual game elements when you are still prototyping. We could, for instance, decide later that we do not actually want to have these pick ups, and then all that effort would go down the drain. Or worse: we could become too attached to something because we have spent too much time refining it and be resistant to changing it out for something better.</p> <p>However, it doesn't hurt to add a bit of refinement to something you know you want to keep, and I personally find it to be a good break from prototyping that keeps me invested in the project.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#move-to-player-effect","title":"Move To Player Effect","text":"<p>Instead of the PickUp objects simply disappearing from thin air when we collect them, we will have them fly into the player and be collected when they reach them.</p> PointPickUp.cs<pre><code>public class PointPickUp : MonoBehaviour\n{\n    [SerializeField] private int _pointValue = 1;\n    [SerializeField] private float _flyAcceleration = 32f;\n    [SerializeField] private float _flyCollectionDistance = 0.5f;\n\n    private float _flySpeed = 0f;\n\n    private PlayerMissiles _targetPlayerMissiles;\n\n    private void Update()\n    {\n        if (_targetPlayerMissiles != null)\n        {\n            _flySpeed += _flyAcceleration * Time.deltaTime;\n\n            transform.position = Vector3.MoveTowards(\n                transform.position,\n                _targetPlayerMissiles.transform.position,\n                _flySpeed * Time.deltaTime\n            );\n\n            if (Vector3.Distance(transform.position, _targetPlayerMissiles.transform.position) &lt;= _flyCollectionDistance)\n            {\n                CollectPoint();\n            }\n        }\n    }\n\n    private void CollectPoint()\n    {\n        Debug.Log(\"I have been collected!\");\n        // TODO: Add a point to playerMissiles.\n        Destroy(gameObject);\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        // Try to find PlayerMissiles Component on entering GO.\n        PlayerMissiles playerCheck = other.GetComponent&lt;PlayerMissiles&gt;();\n\n        // If component was found...\n        if (playerCheck != null)\n        {\n            _targetPlayerMissiles = playerCheck;\n        }\n    }\n}\n</code></pre> Abstract <p>When the <code>PlayerMissiles</code> component is detected, we keep track of it in a class member. Whenever that class member <code>_targetPlayerMissiles</code> is not null, we will move the position of the pick up closer to the player's position by an accelerating velocity per frame. Lastly, when the distances are lower than some set distance, we then trigger the collection.</p> <p>Note that we multiply the acceleration and the velocity by <code>Time.deltaTime</code>. This number is equal to the number of seconds between the last frame and this frame, which has the effect of converting the accleration / velocity to a per-second quantity instead of a per-frame quantity.</p> <p>Note that increasing the velocity each frame gives our pick up some more character by introducing a ramp up to the collection. It also guarantees that the pick up will eventually catch up to the Player even if they are initially faster.</p> <p>Go in Play Mode and give it a try! You can tweak the <code>_flyAcceleration</code> to get some different results. You may want to push back or increase the FOV on your camera to be able to observe the movement better.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#slow-turn-effect","title":"Slow Turn Effect","text":"<p>Right now, the pick up always moves in a straight line from its position to the Player. We can add even more character to the flight by making the velocity direction slowly correct itself over time, which will give the movement a more circular arc than a J-shaped one.</p> <p>To do this, we will first determine the initial direction that the pick up must travel to get to the Player. Since our Player is traveling forward at a considerable speed, that initial direction will become incorrect pretty quickly, and the pick up will likely miss the player.</p> <p>As time goes along, we will gradually correct the velocity direction towards the actual direction from the pick up to the Player, which will cause it to smoothly hook around and eventually reach the player.</p> <p></p> PointPickUp.cs<pre><code>using UnityEngine;\n\npublic class PointPickUp : MonoBehaviour\n{\n    [SerializeField] private int _pointValue = 1;\n    [SerializeField] private float _flyAcceleration = 32f;\n    [SerializeField] private float _flyCollectionDistance = 0.5f;\n    [SerializeField] private float _flyDirectionCorrection = 2f;\n\n    private Vector3 _velocityDirection = Vector2.zero;\n    private float _flySpeed = 0f;\n\n    private PlayerMissiles _targetPlayerMissiles;\n\n    private void Update()\n    {\n        if (_targetPlayerMissiles != null)\n        {\n            // Accelerate the speed\n            _flySpeed += _flyAcceleration * Time.deltaTime;\n\n            Vector3 targetPosition = _targetPlayerMissiles.transform.position;\n\n            // Incrementally correct the current velocity towards the correct one\n            Vector3 correctDirection = Vector3.Normalize(targetPosition - transform.position);\n            _velocityDirection = Vector3.MoveTowards(_velocityDirection, correctDirection, _flyDirectionCorrection * Time.deltaTime);\n\n            // If the position is negative, flip the y velocity positive to keep it positive.\n            if (transform.position.y &lt;= 0f)\n            {\n                _velocityDirection.y = Mathf.Abs(_velocityDirection.y);\n            }\n\n            // Move the transform along the velocity direction at _flySpeed speed.\n            transform.Translate(_velocityDirection * _flySpeed * Time.deltaTime);\n\n            // Check the distance, collect if close enough.\n            if (Vector3.Distance(transform.position, targetPosition) &lt;= _flyCollectionDistance)\n            {\n                CollectPoint();\n            }\n        }\n    }\n\n    private void CollectPoint()\n    {\n        Debug.Log(\"I have been collected!\");\n        // TODO: Add a point to playerMissiles.\n        Destroy(gameObject);\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        // Try to find PlayerMissiles Component on entering GO.\n        PlayerMissiles playerCheck = other.GetComponent&lt;PlayerMissiles&gt;();\n\n        // If component was found...\n        if (playerCheck != null)\n        {\n            _targetPlayerMissiles = playerCheck;\n            _velocityDirection = Vector3.Normalize(playerCheck.transform.position - transform.position);\n        }\n    }\n}\n</code></pre> Abstract <p>If you subtract a vector <code>position</code> from the vector <code>target</code>, the result will be a vector which would move <code>position</code> to <code>target</code>. If you then normalize that vector, you will get the direction from <code>position</code> to <code>target</code>. Commit this to memory, it is a very important technique!</p> <p>When the trigger initially occurs, we will store the initial direction in <code>_velocityDirection</code>.</p> <p>Then, per-update, we will slowly move that initial direction towards the correct direction needed to intercept the Player as it moves along. All the while, we move the pick up along the ever-correcting direction vector by the accelerating speed.</p> <p>Additionally, since our player's position is at y=0 and our points are above the ground, our pick-up may try to go below the ground. If it does, we will fix this issue by simply making the y component of our <code>_velocityDirection</code> positive. This also gives us an interesting bounce effect.</p> <p>Do not worry if this is a bit advanced for you right now. As long as the you get the general idea, you will learn how to manipulate vectors with practice.</p> <p>As you will come to find out, the effort required to make something look good is often a bigger ordeal than just making the thing in the first place! This is why it is a good idea to typically save refinement for later stages so your effort is not wasted!</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#chapter-4-missiles","title":"Chapter 4: Missiles","text":"<p>If you go back to the short preview shown in this series' introduction, you can see that when the player collects the pick ups, small missiles appear spinning around them.</p> <p>To accomplish this we will create a new script which will handle collecting points, spawning missiles, and positioning them around the player. We will also need to create those missile prefab objects, which will contain a basic script that will be evolved in the next chapter.</p> <ol> <li>Missile Prefab</li> <li>Point Collection Response</li> <li>Missile List</li> <li>Easy Visual Improvements</li> </ol>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#1-missile-prefab","title":"1) Missile Prefab","text":"<p>In order to instantiate a GameObject at runtime from a script, we (generally) need to save that object ahead of time as a prefab. So let's go ahead and make our missile objects now.</p> <p>Create an empty GameObject called Missile, and attach the Octohedron model to it as a child just like we did for the Player (though we do not necessarily need to make a ... GFX object this time). Create a new material to color it.</p> <p>For now, we will also create a <code>Missile.cs</code> script that will be attached to our Missile object, though it will not do anything currently. We will need the class to exist since our script which we will use to manage the player's missiles will need to maintain a list of <code>Missile</code> objects.</p> <p>Create a new <code>Missile.cs</code> script, and add it to the Missile object as we have done before. Then, save the missile in your Prefabs folder! You can then delete the missile object from the Hierarchy.</p> <p></p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#2-point-collection-response-playermissilescs","title":"2) Point Collection Response (PlayerMissiles.cs)","text":"<p>Whenever we want to construct some kind of behavior which manages a collection of objects for some specified task, it is almost always a good idea to create a script which decouples the behavior of managing the group from managing the individuals. In this scenario, we need a script to operate individual missiles (<code>Missiles.cs</code>), and then a script to handle collecting, spawning, and choosing which missiles to fire- essentially a manager.</p> <p>We will modify our placeholder <code>PlayerMissiles</code> script for this purpose. It will be a component of the Player GameObject and will be responsible for handling the tasks mentioned above. The first thing we need it to do is let our pick up objects send a message to the script when they are collected.</p> <p>PlayerMissiles.cs<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerMissiles : MonoBehaviour\n{\n    private int _missilePoints = 0;\n\n    public void AddPoint(int points)\n    {\n        _missilePoints += Mathf.Max(0, points);\n        Debug.Log(_missilePoints);\n    }\n}\n</code></pre> PointPickUp.cs (frag)<pre><code>    private void CollectPoint()\n    {\n        _targetPlayerMissiles.AddPoint(_pointValue);\n        Destroy(gameObject);\n    }\n</code></pre></p> <p>Since our pick up script already stores a reference to the <code>PlayerMissiles</code> class it is chasing, adding points to the class is as easy as providing a public method for it to do so. We also use <code>Mathf.Max</code> to ensure the points added is at least 0.</p> <p>I have not mentioned this yet, but we allowed each pick up to have it's point total be a property changeable in the Inspector. This allows us to make pick ups which are worth more points. Lets go ahead and make a pick up which is worth three points.</p> <p>Select one of your pick ups in your scene, Ctrl+D to duplicate it, move it, and change its <code>Point Value</code> property to <code>3</code>. Also create and apply a new material to color it differently.</p> <p>Now, drag it down to your Prefabs folder again and you will get a new prompt, asking if you would like to make this an original prefab or a variant. A variant prefab functions similarly to class inheritance, it defines the variant as a subtype of a base prefab by providing a few overrides that make it distinct. The variant option makes perfect sense here, so use that!</p> <p>Optionally, you can also make it a tad bigger and lower it's flight speed / correction to give it a weightier feel as it flies toward the player.</p> <p></p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#3-missile-list","title":"3) Missile List","text":"<p>The number of points our player has will correspond to how many missiles they currently have ready at any given time. For now, we will just have one point correspond to one missile. This could be a problem in the future if we have hundreds of points (from both a visual and performance stand point), but it will be fine for now.</p> <p>Our <code>PlayerMissiles</code> script will need to create missiles in order to sync up the missile count with their point count. Further, it will need to keep track of those existing missile objects so that they can be fired later when we eventually implement the kill walls, which we will do by keeping a list of them.</p> <p>Before we do some scripting, we also need to designate GameObject in our hierarchy that we want to act as a parent to our spawned missiles, which will also dictate where they appear positionally.</p> <p>To accomplish this, we shall create a new empty object under the Player called Missile Store, which we will move half way between the ground and the our Player GFX transform.</p> PlayerMissiles.cs<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerMissiles : MonoBehaviour\n{\n    [SerializeField] private GameObject _missilePrefab;\n    [SerializeField] private Transform _missileStore;\n    [SerializeField] private float _missileSpawnRadius = 3f;\n\n    private List&lt;Missile&gt; _missileList;\n    private int _missilePoints = 0;\n\n    public void AddPoint(int points)\n    {\n        _missilePoints += Mathf.Max(0, points);\n\n        SyncMissilesToPoints();     // Create missiles to catch up with the points\n    }\n\n    private void Awake()\n    {\n        _missileList = new List&lt;Missile&gt;();\n    }\n\n    /// &lt;summary&gt;\n    /// Creates more missiles to make the missile count equal to the number of missile points.\n    /// &lt;/summary&gt;\n    private void SyncMissilesToPoints()\n    {\n        int missilesToCreate = _missilePoints - _missileList.Count;     // # of missiles needed to sync\n\n        for (int i = 0; i &lt; missilesToCreate; i++)\n        {\n            CreateMissile();\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Instantiates a missile, assigns a random offset to prevent stacking, and adds it to the list.\n    /// &lt;/summary&gt;\n    private void CreateMissile()\n    {\n        // Creates a new instance of the prefab as a child of _missileStore\n        GameObject missileGO = Instantiate(_missilePrefab, _missileStore);\n        Missile missile = missileGO.GetComponent&lt;Missile&gt;();\n\n        Vector3 randomOffset = new Vector3(\n            Random.Range(-_missileSpawnRadius, _missileSpawnRadius),\n            0f,\n            Random.Range(-_missileSpawnRadius, _missileSpawnRadius)\n        );\n\n        missile.transform.localPosition = randomOffset;\n\n        _missileList.Add(missile);\n    }\n}\n</code></pre> Abstract <p>This script gets pretty big, but that is because we are also trying to work some better structure here by using functions and some documentation.</p> <p>First, we create a reference to our missile prefab and the transform we would like to place them under. These will both be populated using the Inspector. We will discuss <code>_missileSpawnRadius</code> in a second.</p> <p>The <code>_missileList</code> is a collection of any active missiles we have spawned. Note that even though it is a collection of <code>Missile</code> objects, the objects have an implied GameObject attached to them since they are a MonoBehavior, and storing them as the <code>Missile</code> component keeps us from having to constantly use <code>GetComponent</code>.</p> <p>The <code>CreateMissile</code> method uses the <code>Instantiate</code> method to create a new instance of our <code>_missilePrefab</code> as a child of <code>_missileStore</code>. We then also generate a random offset for its local position so that all of the missiles are not spawned right on top of each other (Note that the local position is where it lies relative to its parent, similar to when you change the position of children in the Hierarchy). The <code>Missile</code> object of the newly created instance is added to our list.</p> <p>The <code>SyncMissilesToPoints</code> method will determine how many missiles need to make the count in the list one-to-one with the <code>_missilePoints</code>. It needs to be called whenever our point count is changed, so we make a call to it in <code>AddPoints</code>.</p> <p>As a nice touch, we also introduce some C# XML documentation- something that is very worthwhile as your project grows and gets larger. You will want to be able to keep notes on what complex functions and scripts do. The XML documentation also adds intellisense information to anything you put it on- hover your mouse over <code>CreateMissile()</code> in your editor and you'll see!</p> <p>Learn more about C# XML documentation</p> <p>On the Inspector for the Player, you will need to set the <code>Missile Prefab</code> and <code>Missile Store</code> properties or else you will get a null reference exception. Drag-and-drop from the Project window Prefab folder to set the prefab and drag-and-drop the Missile Store GameObject to get the transform.</p> <p>Test your game and you will see new missiles appearing as you collect points, nice!</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#4-easy-visual-improvements","title":"4) Easy Visual Improvements","text":"<p>While we are at it, we will apply some script-driven animation to our missiles in order to give them a bit more life.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#store-rotation","title":"Store Rotation","text":"<p>By rotating our Missile Store we can create the effect of our missiles orbiting around the Player which looks pretty cool. It is also very simple to implement because of how our Player's hierarchy is organized.</p> PlayerMissiles.cs (frag)<pre><code>...\n\n[SerializeField] private float _storeSpinSpeed = 180f;\n\n...\n\nprivate void Update()\n{\n    _missileStore.Rotate(new Vector3(0f, _storeSpinSpeed * Time.deltaTime, 0f));\n}\n</code></pre> Abstract <p>The Y-Axis rotation applied per frame gives us a Z-X plane rotation of the missile store, which gives us our orbiting motion. Multiplying the <code>_storeSpinSpeed</code> by <code>Time.deltaTime</code> turns it into a degrees-per-second speed instead of a degrees-per-frame speed.</p> <p>Now, if you tried this in Play Mode, you likely noticed a small issue...</p> <p></p> <p>The rotation of the store also causes our missiles to point in the wrong direction! This is easy to fix, we will just have the missiles also correct their rotation to be forward-facing each frame inside of <code>Missile.cs</code>.</p> Missile.cs<pre><code>using UnityEngine;\n\npublic class Missile : MonoBehaviour\n{\n    private void Update()\n    {\n        transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);\n    }\n}\n</code></pre> Abstract <p>Each frame, set the global rotation of the missile to be a rotation which faces down the positive Z axis.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#missile-spin","title":"Missile Spin","text":"<p>We can also add a little more character by having our missiles spin on the Z-axis passively.</p> Missile.cs<pre><code>using UnityEngine;\n\npublic class Missile : MonoBehaviour\n{\n    [SerializeField] private float _spinSpeed = 200f;\n\n    private float _currentSpinAngle = 0f;\n\n    private void Awake()\n    {\n        // Apply a random starting angle \n        _currentSpinAngle += Random.Range(0f, 359f);\n    }\n\n    private void Update()\n    {\n        transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);  // Reset rotation\n\n        _currentSpinAngle += _spinSpeed * Time.deltaTime;   // Increment the spin angle by time difference\n        transform.Rotate(0f, 0f, _currentSpinAngle);        // Rotate to spin angle\n    }\n}\n</code></pre> Abstract <p>Note that the <code>Transform.Rotate(Vector3)</code> method typically applies a rotation additive to the existing one, but since our assignment on line 17 overrides the previous rotation, the spin needs to be stored in a variable.</p> <p>We also so <code>Time.deltaTime</code> being used in a slightly different way here. If you increment a variable by <code>Time.deltaTime</code> each frame, that variable effectly acts as a stopwatch by accumulating the number of real-world seconds.</p> <p>Lastly, we also apply a random starting angle to the missile so that missiles added in the same frame are generally not in phase with each other, which may looks weirdly artifical.</p> <p>Previously, I mentioned that it is generally best not to work on visual refinement while prototyping, since we may wind up needing to scrap entire features later down the line. However, I frequently break this rule.</p> <p>I personally find that occasionally making visual refinements keeps me invested in longer projects- having something nice to look at is very appealing and makes you feel like you are getting somewhere, which combats burn-out a bit. It also gives you something neat to show your friends, which very much helps with encouragement (if you have good friends that is!).</p> <p>It is a fine line that you will have to set for yourself, but I generally find easy slam-dunks like what we just implemented to be worth the time every once in a while.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#chapter-5-kill-walls","title":"Chapter 5: Kill Walls","text":"<p>Our primary obstacle, Kill Walls, will be the basis of our game's challenge. Kill Walls will have a specific amount of Hit Points (HP) that need to be defeated using missiles, or else the Player will run into them and lose. Each missile collected from a pick up will damage a wall for 1 HP.</p> <p>When the player approaches a wall, they will automatically fire as many missiles as necessary to destroy the wall. If they cannot, they will collide with it and be destroyed!</p> <ol> <li>Kill Wall Prefab</li> <li>Player Killing Behavior</li> <li>Missile Launching</li> </ol>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#1-kill-wall-prefab","title":"1) Kill Wall Prefab","text":""},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#road-extension","title":"Road Extension","text":"<p>Actually, before we make our first Kill Wall, go ahead and extend your road if you haven't already. Use Ctrl+D to duplicate the Road group and move it down the Z-Axis such that it is seamless with the original road.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#wall","title":"Wall","text":"<p>As usual, we will create an empty GameObject that will house everything related to the Kill Wall- name the new empty GameObject Kill Wall.</p> <p>To the Kill Wall object, add a Cube 3D Object as a child of it and scale it so that it spans the entire road and is much taller. Giving it some thickness will help with collision detection as well. Go ahead and make a material to color the cube as well- red is nice and menacing!</p> <p>We actually want the collider of the wall to be on the Kill Wall GameObject, not the Cube, so delete the Cube one and add an appropriately sized <code>BoxCollider</code> to the Kill Wall. We do this because colliders will only report collisions to scripts immediately on the same GameObject, not their parents.</p> <p>Create a new script <code>KillWall.cs</code> and add it to the Kill Wall, we will implement it later.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#shoot-trigger","title":"Shoot Trigger","text":"<p>As mentioned before, the player will automatically fire their missiles any Kill Wall it approaches. To accomplish this, we will create a trigger collider some distance in front of any kill wall which will tell the player to shoot at the wall when they enter it.</p> <p>Create a new empty GameObject as a child of the Kill Wall and name it Shoot Trigger. Move it to be a fair distance in front of the wall, and <code>AddComponent &gt; Box Collider</code>. Change the parameters of the collider to make it also span the entire road so the player cannot miss it.</p> <p>Create a new script <code>ShootTrigger.cs</code> and add it to the Shoot Trigger, we will implement it soon.</p> <p>Turn your Kill Wall object into a prefab so we can use it again later!</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#2-player-killing-behavior","title":"2) Player Killing Behavior","text":"<p>We will add some behavior to allow the Kill Walls to destroy the player when they touch them.</p> <p>In order to do this, we need to describe how the Player itself should 'die'. For our basic prototype of this game, we will simply destroy the GameObject that represents them, but we will need to put that code somewhere. Ideally, the Player will have a publically-scoped method to trigger a death.</p> <p>It wouldn't make much sense for our <code>PlayerMovement</code> or <code>PlayerMissiles</code> script to also handle death behavior, so we will add a new script to the player, <code>Player.cs</code>, which will handle general player behavior, such as dying.</p> Player.cs<pre><code>using UnityEngine;\n\npublic class Player : MonoBehaviour\n{\n    public void Die()\n    {\n        Destroy(gameObject);\n    }\n}\n</code></pre> <p>Then we can have our <code>KillWall</code> script detect collisions with anything that contains a <code>Player</code> script and trigger the <code>Die</code> method if so.</p> KillWall.cs<pre><code>using UnityEngine;\n\npublic class KillWall : MonoBehaviour\n{\n\n    [SerializeField] private int _hitPoints = 5;\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        Player playerCheck = collision.gameObject.GetComponent&lt;Player&gt;();\n        if (playerCheck != null)\n        {\n            playerCheck.Die();\n        }\n    }\n}\n</code></pre> Abstract <p>Once again, we make sure that we check that the opposing collider is actually a <code>Player</code> class by comparing it against <code>null</code>, which avoids a possible null reference exception should something else incidentally collide with the wall.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#3-missile-launching","title":"3) Missile Launching","text":"<p>In a similar vein, our <code>ShootTrigger</code> script shoud detect a <code>Player</code> entering its trigger volume and tell the player to launch as many missiles as necessary to destroy the <code>KillWall</code> it is attached to. This will take a bit more work, though!</p> <p>This is going to require a few changes to four scripts: <code>KillWall</code>, <code>Missile</code>, <code>PlayerMissiles</code>, and <code>ShootTrigger</code>.</p> <ul> <li><code>KillWall</code> will need to be able to be damaged and track its damage.</li> <li><code>Missile</code> will need to be given behavior to chase after a kill wall and damage it when it is close enough</li> <li><code>PlayerMissiles</code> needs a public method to fire exactly the right amount of missiles to kill a wall.</li> <li><code>ShootTrigger</code> needs to track which wall it is registered to and trigger the method mentioned above for <code>PlayerMissiles</code> when the player enters.</li> </ul> <p>We double-back to our <code>KillWall.cs</code> and make a few changes to track HitPoints, take damage, and allow destruction.</p> KillWall.cs<pre><code>using UnityEngine;\n\npublic class KillWall : MonoBehaviour\n{\n    [SerializeField] private int _hitPoints = 5;\n\n    public void TakeDamage(int damage)\n    {\n        _hitPoints -= damage;\n\n        if (_hitPoints &lt;= 0)\n        {\n            Die();\n        }\n    }\n\n    private void Die()\n    {\n        Destroy(gameObject);\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        Player playerCheck = collision.gameObject.GetComponent&lt;Player&gt;();\n        if (playerCheck != null)\n        {\n            playerCheck.Die();\n        }\n    }\n\n    public int HitPoints { get =&gt; _hitPoints; }\n}\n</code></pre> Abstract <p>Note at the bottom that we create a Property called <code>HitPoints</code> which exposes <code>_hitPoints</code> to public reading without allowing it to be publically writable.</p> <p>Next, we will create a method on our <code>Missile</code> script which allows it to fire itself at a provided <code>KillWall</code> object.</p> Missile.cs<pre><code>using UnityEngine;\n\npublic class Missile : MonoBehaviour\n{\n    [SerializeField] private int _attackDamage = 1;\n    [SerializeField] private float _spinSpeed = 200f;\n    [SerializeField] private float _flySpeed = 30f;\n    [SerializeField] private float _detonateDistance = 3f;\n\n\n    private KillWall _killWallTarget;\n    private float _currentSpinAngle = 0f;\n\n    public void FireAtWall(KillWall killWall)\n    {\n        _killWallTarget = killWall;\n        transform.parent = null;    // Unparent so it does not follow the player\n    }\n\n    private void Awake()\n    {\n        _currentSpinAngle += Random.Range(0f, 359f);\n    }\n\n    private void Update()\n    {\n        if (_killWallTarget != null)\n            FlyAtTarget();\n        else\n            DoIdleAnimation();\n    }\n\n    private void FlyAtTarget()\n    {\n        Vector3 targetPosition = _killWallTarget.transform.position;\n\n        // Move towards wall\n        transform.position = Vector3.MoveTowards(transform.position, targetPosition, _flySpeed * Time.deltaTime);\n\n        transform.LookAt(targetPosition, Vector3.up);   // Look towards the wall we are flying at\n\n        // If close enough, do damage and destroy myself.\n        if (Vector3.Distance(transform.position, targetPosition) &lt;= _detonateDistance)\n        {\n            _killWallTarget.TakeDamage(_attackDamage);\n            Destroy(gameObject);\n        }\n    }\n\n    private void DoIdleAnimation()\n    {\n        transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);\n\n        _currentSpinAngle += _spinSpeed * Time.deltaTime;\n        transform.Rotate(0f, 0f, _currentSpinAngle);\n    }\n\n    public int AttackDamage { get =&gt; _attackDamage; }\n}\n</code></pre> Abstract <p>Note that we moved the original <code>Update</code> behavior to <code>DoIdleAnimation</code>, which is sidelined one the missile has a valid target. This actually works pretty similarly to our <code>PointPickUp</code>'s chase behavior.</p> <p>Also note that we unparent the missile from the Player when we fire, so its position is not affected by the player's movement any longer.</p> <p>Next, we need to change the <code>PlayerMissiles</code> script to have a public method to dispatch exactly enough missiles to destroy a given <code>KillWall</code>:</p> PlayerMissiles.cs<pre><code>...\n\npublic void FireMissilesAtTarget(KillWall killWall)\n{\n    // Total strength of all fired missiles.\n    int cumulativeDamage = 0;\n\n    // Iterate through all missiles BACKWARDS through the list.\n    // Stop if cumulative damage is high enough to destroy wall or \n    // we run out of missiles.\n    for (int i = _missileList.Count - 1; i &gt;= 0 &amp;&amp; cumulativeDamage &lt; killWall.HitPoints; i--)\n    {\n        Missile nextMissile = _missileList[i];\n\n        nextMissile.FireAtWall(killWall);\n        cumulativeDamage += nextMissile.AttackDamage;\n\n        _missileList.RemoveAt(i);\n        _missilePoints -= nextMissile.AttackDamage;\n    }\n}\n\n...\n</code></pre> Abstract <p>We iterate through each missile in the <code>_missileList</code> from back to front, firing them at the wall until the cumulative damage of the fired missiles is enough to kill the wall or we run out.</p> <p>We go from back to front because it is generally more performant to unshift items from a container at the back than the front.</p> <p>It is also important to remember to update our number of <code>_missilePoints</code> after firing off a missile. The number of points a missile was worth is its <code>AttackDamage</code>, though that will always be <code>1</code> for now.</p> <p>Lastly, we just need to update the <code>ShootTrigger</code> to know which <code>KillWall</code> it is attached to and tell the <code>PlayerMissiles</code> to <code>FireMissilesAtTarget</code> when it enters the trigger volume.</p> ShootTrigger.cs<pre><code>using UnityEngine;\n\npublic class ShootTrigger : MonoBehaviour\n{\n    [SerializeField] private KillWall _attachedKillWall;\n\n    private void OnTriggerEnter(Collider other)\n    {\n        PlayerMissiles playerMissilesCheck = other.GetComponent&lt;PlayerMissiles&gt;();\n\n        if (playerMissilesCheck != null)\n        {\n            playerMissilesCheck.FireMissilesAtTarget(_attachedKillWall);\n        }\n    }\n}\n</code></pre> <p>Drag-and-drop the Kill Wall to the <code>Attached Kill Wall</code> property.</p> <p>This was pretty code-heavy, but the result is pretty cool! You should now notice some of your collected missiles destroying the wall as you approach.</p> <p>Try collecting less than five missiles as well. You will see your missiles launch, but not enough will be fired to destroy the wall.</p> <p>It looks pretty rough right now. This guide will eventually be expanded with a module dedicated to visual effects and particles!</p> <p></p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#chapter-6-user-interface","title":"Chapter 6: User Interface","text":"<p>One major problem with our game is that the player cannot see how many missiles are required to destroy any given Kill Wall. Likewise, they cannot see how many missiles they own without painstakingly counting.</p> <p>We can fix both those problems by adding a rudimentary user interface which displays counters for wall HP and the missile count.</p> <ol> <li>UI for Kill Walls</li> <li>UI for Missile Count</li> </ol>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#1-ui-for-kill-walls","title":"1) UI for Kill Walls","text":"<p>To keep things simple, we will use world space canvases that allow us to project UI elements on physical planes in our scene.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#create-the-ui","title":"Create the UI","text":"<p>On the Kill Wall prefab, create a new <code>UI &gt; Canvas</code>, which serves as a root for all of our UI elements. In order to make the UI appear in world space, change the Canvas' <code>Render Mode</code> to <code>World Space</code>.</p> <p>Now we can position our canvas, which is wildly too large. Reset the <code>Rect Transform</code> component (by using the ellipses button in the top right of the component), and change the <code>width</code> and <code>height</code> to <code>5</code>. Then, move the canvas so that it is just in front of the Kill Wall's -Z face center <code>(0, 4, -2.6)</code>.</p> <p>You can then add a <code>UI &gt; Panel</code> object to the canvas, which will help our text stand out from the Kill Wall. It looks a little weird and pixelated- set the <code>Pixels Per Unit Multiplier</code> on the <code>Image</code> component to <code>5</code> and it will look correct.</p> <p>Now, to the Panel, add a <code>UI &gt; Text - TextMeshPro</code>. You will need to do a series of things to get it to fit correctly within the Panel. </p> Text Mesh Pro <p>Note that the first time you add a <code>Text - TextMeshPro</code> object, you will get a pop up saying you need to import the essentials package, which must do to get a working font. You do not need to import the extras.</p> <ol> <li>In the top-left anchor box, hold <code>ALT+Shift</code> and click on the bottom-right option to set the element to stretch across the entire Panel.</li> <li>Check the <code>Auto-Size</code> property.</li> <li>In <code>Auto Size Options</code>, set <code>Min</code> to <code>1</code> to allow the the text to shrink into the box.</li> <li>Change the text to \"0\".</li> <li>Change the alignment to <code>middle</code> and <code>center</code>.</li> </ol> <p>You should now see your \"0\" text is centered within the panel taking up as much space as is allowable.</p> <p></p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#program-the-ui","title":"Program the UI","text":"<p>We need the text of our Text(TMP) object to be the numerical HP of the Kill Wall it represents, which is easy enough to do.</p> <p>In order to make the <code>KillWall</code> HP monitorable, we must make one small adjustment to the script. KillWall.cs (frag)<pre><code>using System;\nusing UnityEngine;\n\npublic class KillWall : MonoBehaviour\n{\n    public Action&lt;int&gt; OnHitPointsChanged;\n\n    [SerializeField] private int _hitPoints = 5;\n\n    public void TakeDamage(int damage)\n    {\n        _hitPoints -= damage;\n\n        if (_hitPoints &lt;= 0)\n        {\n            Die();\n        }\n\n        OnHitPointsChanged?.Invoke(HitPoints);\n    }\n\n    ...\n</code></pre></p> Abstract <p>Actions allow other scripts to 'subscribe' to them and register some kind of response whenever the action is invoked. In this example, our <code>KillWall</code> will invoke the <code>OnHitPointsChanged</code> method, transmitting the number of HitPoints in a signal to any scripts which are subscribed to the Action.</p> <p>Our UI object can subscribe to the action, read the int trasmitted with the invocation, and update the UI accordingly.</p> <p>This is significantly more efficient than having the UI constantly check the value of the the <code>KillWall</code>'s HitPoints each frame and updating the text accordingly. Actions are great for these circumstances where things only need to periodically respond in reaction to an event.</p> <p>Also note the strange notation of the <code>?</code> operator. Actions are a nullable type, which means that they can have a valid value or be <code>null</code>. Using the <code>?</code> operator with a nullable type will only execute the instruction if the given nullable is non-null.</p> <p>Learn more about events, delegates, and actions</p> <p>Learn more about nullable types</p> <p>Create a new script <code>KillWallUI</code> and attach it to the Text(TMP) object.</p> KillWallUI.cs<pre><code>using UnityEngine;\nusing TMPro;\n\n[RequireComponent(typeof(TextMeshProUGUI))]\npublic class KillWallUI : MonoBehaviour\n{\n    [SerializeField] private KillWall _killWall;\n\n    private TextMeshProUGUI _tmp;\n\n    private void Awake()\n    {\n        _tmp = GetComponent&lt;TextMeshProUGUI&gt;();\n    }\n\n    private void OnEnable()\n    {\n        _killWall.OnHitPointsChanged += UpdateText;\n        UpdateText(_killWall.HitPoints)\n    }\n\n    private void OnDisable()\n    {\n        _killWall.OnHitPointsChanged -= UpdateText;\n    }\n\n    private void UpdateText(int hitPoints)\n    {\n        _tmp.text = hitPoints.ToString();\n    }\n}\n</code></pre> Abstract <p>To register a function to an Action, we <code>+=</code> a function with an appropriate parameter list (that being one <code>int</code> type) to the Action. Whenever you register to an Action, must also deregister the function should the script ever be destroyed or be disabled. This is why this behaviour is done on every enable or activate (which also trigger on awake and on destroy respectively).</p> <p>Changing the text is simple as can be: Just set the <code>text</code> property to a string of the transmitted integer.</p> <p>Do not forget to set the <code>_killWall</code> property of the <code>KillWallUI</code> script instance to that on the Kill Wall object!</p> <p>Not only can we now see the amount of HP a wall has, but it will actively count down to 0 as it takes damage!</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#2-ui-for-missile-count","title":"2) UI for Missile Count","text":"<p>This will work almost identically to the UI rig we created for the Kill Wall.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#create-the-ui_1","title":"Create the UI","text":"<p>As a child of the Player, create a new empty GameObject Missile UI and add a series of items as consecuative children of each other: <code>UI &gt; Canvas</code>, <code>UI &gt; Panel</code>, <code>UI &gt; Text - TextMeshPro</code>. Configure them the same way as you did the UI stack we just made for the Kill Wall, change the Panel <code>Reference Pixels Per Unit</code> and make the same configuration to the <code>TextMeshPro</code> object.</p> <p>Also, make sure to set the <code>Render Mode</code> of the Canvas to <code>World Space</code> and be sure to center its rect transform. We will make this Canvas slightly smaller, using a <code>width</code> and <code>height</code> of <code>3</code>.</p> <p>Place the Missile UI GameObject along the ground. We want the UI Panel to appear on top of the road slightly behind the Player so position the Missile UI accordingly and then rotate the Canvas 90 degrees on the X-Axis to make it flush against the ground.</p> <p>The current colors do not contrast very well against our bright road. On the Panel, increase the opacity of the Image component's <code>Color</code> property a bit. Then, on the <code>Text (TMP)</code> object, change the <code>Vertex Color</code> to a dark grey.</p> <p></p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#program-the-ui_1","title":"Program the UI","text":"<p>Again, this will work almost identically to the last UI we rigged up: Create an Action on the <code>PlayerMissiles</code> script which is invoked whenever the number of <code>_missilePoints</code> changes, and update the UI accordingly.</p> PlayerMissiles.cs (frag)<pre><code>using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\nusing Random = UnityEngine.Random;\n\npublic class PlayerMissiles : MonoBehaviour\n{\n    public Action&lt;int&gt; OnMissilesChanged;\n\n    [SerializeField] private GameObject _missilePrefab;\n\n    ...\n\n    public void AddPoint(int points)\n    {\n        _missilePoints += Mathf.Max(0, points);\n\n        OnMissilesChanged?.Invoke(_missilePoints);\n        SyncMissilesToPoints();     // Create missiles to catch up with the points\n    }\n\n    ...\n\n    public void FireMissilesAtTarget(KillWall killWall)\n    {\n        int cumulativeDamage = 0;\n\n        for (int i = _missileList.Count - 1; i &gt;= 0 &amp;&amp; cumulativeDamage &lt; killWall.HitPoints; i--)\n        {\n            ...\n\n            OnMissilesChanged?.Invoke(_missilePoints);\n        }\n    }\n\n    ...\n\n    public int MissilePoints {get =&gt; _missilePoints; }\n}\n</code></pre> Abstract <p>We invoke the <code>OnMissilesChanged</code> action whenever we gain missile points or fire a missile.</p> <p>Note that we must add <code>using System;</code> to be able to use Actions. However, both the <code>UnityEngine</code> and <code>System</code> namespace introduce their own, identically-named <code>Random</code> class, which causes an ambigious call error when we make a <code>Random</code> call later in the file.</p> <p>To fix this, the code on line 6 specifies that <code>Random</code> always refers to the <code>UnityEngine</code> implementation.</p> <p>Now create another script <code>MissileUI</code> and attach it to the Missile UI -&gt; Panel -&gt; Text (TMP) GameObject.</p> MissileUI.cs<pre><code>using UnityEngine;\nusing TMPro;\n\n[RequireComponent(typeof(TextMeshProUGUI))]\npublic class MissilesUI : MonoBehaviour\n{\n    [SerializeField] private PlayerMissiles _playerMissiles;\n\n    private TextMeshProUGUI _tmp;\n\n    private void Awake()\n    {\n        _tmp = GetComponent&lt;TextMeshProUGUI&gt;();\n    }\n\n    private void OnEnable()\n    {\n        _playerMissiles.OnMissilesChanged += UpdateText;\n        UpdateText(_playerMissiles.MissilePoints);\n    }\n\n    private void OnDisable()\n    {\n        _playerMissiles.OnMissilesChanged -= UpdateText;\n    }\n    private void UpdateText(int missileCount)\n    {\n        _tmp.text = missileCount.ToString();\n    }\n}\n</code></pre> <p>Wow, this looks awfully familiar, doesn't it? Do not forget to populate the <code>Player Missiles</code> property of the <code>MissileUI</code> script with the Player's <code>Player Missiles</code> instance.</p> <p></p> <p>A fair amount of code has gone into getting what you see above working, good job getting this far!</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#chapter-7-hazards","title":"Chapter 7: Hazards","text":"<p>In order for our game to be engaging, we need to make collecting missiles more challenging.</p> <p>We will accomplish this by creating Hazard Zones, which will constantly drain the number of missile points the Player has if they enter their trigger volume. This will be detrimental to the player if they accidentally cross them, but it will not severely punish them by instantly destroying them.</p> <p>In fact, we could actually design some interesting scenarios where it is worthwhile to go through a hazard zone to get some points on the other side.</p> <ol> <li>Hazard Zone Prefab</li> <li>Hazard Zone Script</li> <li>Moving Hazard</li> </ol>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#1-hazard-zone-prefab","title":"1) Hazard Zone Prefab","text":"<p>Our Hazard Zones will be rectangular, transparant volumes which the Player can pass through to negative effect.</p> <p>Create a new empty GameObject \"Hazard Zone\". Attach a <code>BoxCollider</code> component to the Hazard Zone, but leave its size alone for now. Check the <code>Is Trigger</code> property. As a child of the Hazard Zone, add a 3D cube and remove its <code>BoxCollider</code> component.</p> <p>We must move the <code>Center: Y</code> property of the Hazard Zone's <code>BoxCollider</code> to <code>0.5</code> to make it flush with the road. Further, do the same with the <code>Position:Y</code> of the Cube.</p> <p>Change the scale of the Hazard Zone transform itself to make both the graphical cube and the trigger collider larger. </p> <p>Lastly, a new material. Like every other time, we will apply it to the cube and give it a red color. However, you will also change <code>Surface Type</code> from <code>Opaque</code> to <code>Transparent</code>, which will allow us to use the alpha value of the <code>Base Map</code> to control how see-through the material is. Change the color to a reddish color with a lowered alpha value.</p> <p>Save the Hazard Zone as a prefab.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#2-hazard-zone-script","title":"2) Hazard Zone Script","text":"<p>When the Player enters the trigger volume on the Hazard Zone, their missile points should be drained over time until the leave the volume. We can accomplish this by reducing their missile points by one on some reoccuring interval.</p> <p>In order to accomplish this, we must give <code>Missile.cs</code> a function to destroy themselves, and <code>PlayerMissiles.cs</code> needs to be upgraded with a public method to deduct missile points, which will then destroy some of the managed missiles to compensate.</p> Missiles.cs (frag)<pre><code>...\n\npublic void DestroyMissile()\n{\n    Destroy(gameObject);\n}\n\n...\n</code></pre> PlayerMissiles.cs (frag)<pre><code>...\n\npublic void RemoveMissilePoints(int points)\n{\n    _missilePoints -= Mathf.Max(0, points);\n    _missilePoints = Mathf.Max(0, _missilePoints);  // Prevent negative points\n\n    OnMissilesChanged?.Invoke(_missilePoints);\n    SyncMissilesToPoints();\n}\n\n...\n\nprivate void SyncMissilesToPoints()\n{\n    int missilesToCreate = _missilePoints - _missileList.Count;     // # of missiles needed to sync\n\n    if (missilesToCreate &gt;= 0)\n    {\n        for (int i = 0; i &lt; missilesToCreate; i++)\n        {\n            CreateMissile();\n        }\n    }\n    else\n    {\n        int missilePointsToDestroy = Mathf.Abs(missilesToCreate);\n\n        for (int i = _missileList.Count - 1; i &gt;= 0 &amp;&amp; missilePointsToDestroy &gt; 0; i--)\n        {\n            Missile nextMissile = _missileList[i];\n            missilePointsToDestroy -= nextMissile.AttackDamage;\n\n            _missileList.RemoveAt(i);\n            nextMissile.DestroyMissile();\n        }\n    }\n}\n\n...\n</code></pre> Abstract <p>Note that since it is possible for <code>missileToCreate</code> to be negative now, <code>SyncMissilesToPoints</code> was upgraded to have separate behavior for when missiles need to be removed. Similarly to firing missiles, we remove missiles from the back of the list (for efficiency purposes) by de-listing them and calling the <code>DestroyMissile</code> method we created.</p> <p>Create a new script <code>HazardZone.cs</code>, and attach it to the Hazard Zone object as a component.</p> HazardZone.cs<pre><code>using UnityEngine;\n\n[RequireComponent(typeof(Collider))]\npublic class HazardZone : MonoBehaviour\n{\n    [SerializeField] private float _ticksPerSecond = 1f;\n\n    private PlayerMissiles _targetPlayerMissiles;\n\n    private bool _damagingPlayer;\n    private float _tickInterval;\n    private float _timeSinceLastTick;\n\n    private void Awake()\n    {\n        _tickInterval = 1 / _ticksPerSecond;\n        _damagingPlayer = false;\n        _timeSinceLastTick = _tickInterval;\n    }\n\n    private void Update()\n    {\n        if (_damagingPlayer)\n        {\n            // Accumulate time, damage the player and reset the accumulation when the interval is reached.\n            _timeSinceLastTick += Time.deltaTime;\n            if (_timeSinceLastTick &gt;= _tickInterval)\n            {\n                DamagePlayer();\n                _timeSinceLastTick = 0f;\n            }\n        }\n    }\n\n    private void DamagePlayer()\n    {\n        _targetPlayerMissiles.RemoveMissilePoints(1);\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        PlayerMissiles playerMissiles = other.gameObject.GetComponent&lt;PlayerMissiles&gt;();\n        if (playerMissiles != null)\n        {\n            _damagingPlayer = true;\n            _timeSinceLastTick = (3 * _tickInterval) / 4;   // Very small grace period\n            _targetPlayerMissiles = playerMissiles;\n        }\n    }\n\n    private void OnTriggerExit(Collider other)\n    {\n        PlayerMissiles playerMissiles = other.gameObject.GetComponent&lt;PlayerMissiles&gt;();\n        if (playerMissiles != null)\n        {\n            _damagingPlayer = false;\n            _targetPlayerMissiles = null;\n        }\n    }\n}\n</code></pre> Abstract <p>We start by defining a <code>_ticksPerSecond</code> field which describes how many times the player should be damaged per second that they remain in the trigger volume. This is then internally converted to a <code>_tickInterval</code> value (by taking <code>1 / _ticksPerSecond</code>) to be equal to the number of seconds it takes to do one tick of damage.</p> <p>We do this because it is easier to understand the damage rate as a number of ticks per second getting larger as it becomes more threatening, rather than an interval getting smaller as it becomes more dangerous (which is what the script needs to know to do the damage).</p> <p>When a <code>PlayerMissiles</code> object enters the volume, it is tracked and <code>_damagingPlayer</code> is set to true to allow our damage logic to occur per-frame. We also pre-set the tick timer <code>_timeSinceLastTick</code> to 75% so they player has a very small grace period before they take their first instance of contact damage with the zone.</p> <p>Per update, we accumulate time into <code>_timeSinceLastTick</code> using <code>Time.deltaTime</code>, and if it is greater than the interval, the player is damaged and the timer resets.</p> <p>When the <code>PlayerMissiles</code> exits the volume, we untrack the object and stop damaging the player.</p> <p>Make your Hazard Zone a bit longer and push back your Kill Wall a bit (adding another road segment if necessary). I personally bumped up the <code>Ticks Per Second</code> property to <code>2</code>. Test it out in Play Mode!</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#3-moving-hazard","title":"3) Moving Hazard","text":"<p>For our very last addition to our prototype, we will up the ante a little by making a moving hazard. This hazard will Ping-Pong horizontally along the road, so the player will need to actively dodge it.</p> <p>We will create a general purpose script which can Ping-Pong something on the X-Axis. Create a new script <code>XPingPong.cs</code>.</p> XPingPong.cs<pre><code>using UnityEngine;\n\npublic class XPingPong : MonoBehaviour\n{\n    [SerializeField] private float _xMinimum = -8f;\n    [SerializeField] private float _xMaximum = 8f;\n\n    [SerializeField] private float _movementSpeed = 5f;\n\n    private bool _movingToMaximum = true;\n\n    private Vector3 _maximumPosition;\n    private Vector3 _minimumPosition;\n\n    private void Awake()\n    {\n        _maximumPosition = new Vector3(_xMaximum, transform.position.y, transform.position.z);\n        _minimumPosition = new Vector3(_xMinimum, transform.position.y, transform.position.z);\n    }\n\n    private void Update()\n    {\n        if (_movingToMaximum)\n        {\n            transform.position = Vector3.MoveTowards(transform.position, _maximumPosition, _movementSpeed * Time.deltaTime);\n            if (Vector3.Distance(transform.position, _maximumPosition) &lt;= 0.5f)\n            {\n                _movingToMaximum = false;\n            }\n        }\n        else\n        {\n            transform.position = Vector3.MoveTowards(transform.position, _minimumPosition, _movementSpeed * Time.deltaTime);\n            if (Vector3.Distance(transform.position, _minimumPosition) &lt;= 0.5f)\n            {\n                _movingToMaximum = true;\n            }\n        }\n    }\n}\n</code></pre> Abstract <p>We define a x minimum and maximum for the transform to translate between. That range is then converted to two positions <code>_maximumPosition</code> and <code>_minimumPosition</code>.</p> <p>Per Update, we will move towards either the <code>_maximumPosition</code> or <code>_minimumPosition</code>, swapping between the two as we reach either of them. Pretty simple!</p> <p>We can now add this script to any object we want to ping pong on our road. You could even add it to your Point PickUps, but you would need to create a third intermediary script to disable the ping-pong behavior when the pick up starts flying at the Player, which may be a good exercise for your own time.</p> <p>Speaking of bonus exercise, you could also try creating a Spinning hazard which has a constant Y-Axis rotation. This would actually be easier to implement as well, since you do not need to cache positional endpoints. The <code>Transform.Rotate</code> method would work well for making the spinning behavior. Give it a try on your own!</p> <p>Note, you would likely need to crank up the <code>Ticks Per Second</code> on these moving hazards, as they may pass out of the player before they can do any worry-some damage.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#chapter-8-level-creation-building","title":"Chapter 8: Level Creation &amp; Building","text":"<p>We have a little bit more housekeeping to do before our little prototype is finished! We will want to flesh out our level to show off more mechanics, add some controls which allow us to reset and exit our game, and create a full build of the game!</p> <ol> <li>PointPickUp.cs Fix</li> <li>Level Creation</li> <li>GameManager</li> <li>Creating a Build</li> </ol>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#1-pointpickupcs-fix","title":"1) PointPickUp.cs Fix","text":"<p>We need to make one small change to our <code>PointPickUp.cs</code> script. As you may have noticed, rotating one of these pick ups on the Y-Axis can cause their tracking logic to completely break. This is because <code>Transform.Translate</code> works according to local space.</p> <p>To fix this, we must simply unparent pick ups once they start flying and ensure they are facing along the forward direction, similar to what we do for firing missiles.</p> PointPickUp.cs (frag)<pre><code>private void OnTriggerEnter(Collider other)\n\n...\n\n    {\n        // Try to find PlayerMissiles Component on entering GO.\n        PlayerMissiles playerCheck = other.GetComponent&lt;PlayerMissiles&gt;();\n\n        // If component was found...\n        if (playerCheck != null)\n        {\n            transform.parent = null;\n            transform.rotation = Quaternion.LookRotation(Vector3.forward);\n            _targetPlayerMissiles = playerCheck;\n            _velocityDirection = Vector3.Normalize(playerCheck.transform.position - transform.position);\n        }\n    }\n}\n</code></pre>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#2-level-creation","title":"2) Level Creation","text":"<p>We ought to extend our road out a bunch and add more content to it in order to show off what we have made!</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#hierarchy-organization","title":"Hierarchy Organization","text":"<p>Before we start, create a new empty GameObject Environment and reset its <code>Transform</code> component. We will place almost every physical GameObject that composes our level as a child of it- The road segments, the Point PickUps, any Kill Walls, and Hazard Zones. I will also fold our Directional Light and Global Volume in there as well. We will not include the Camera Rig or Player, in this Environment object, though.</p> <p>Furthermore, we will create a few more empty GameObjects in the Environment: Roads, Pick Ups, Kill Walls, and Hazard Zones, which we will move all objects of the respective types under. </p> <p>This will make our hierarchy MUCH cleaner. It also helps us separate important GameObjects like our Camera Rig and our Player out from less important features.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#level-building","title":"Level Building","text":"<p>Add a few more road segments to the level and fill it up with Kill Walls, Hazards, and Pick Ups in various configurations to make an interesting level! At the end of the level, just create a Kill Wall with too much health to destroy so the player does not go off the end of the game. Try using some moving hazards as well!</p> <p>The following is a little bit of advice on this process.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#pick-up-prefabs","title":"Pick Up Prefabs","text":"<p>It is pretty satisfying to pick up multiple points in a \"string\", so let's just create some Point String prefabs which are little groups of pick ups in a sequence. I also created a diamond string of four points.</p> <p> </p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#pick-up-and-hazard-synergy","title":"Pick Up and Hazard Synergy","text":"<p>By combining hazards with pick ups intelligently, we can create sections of our levels which allow some skill expression by the player, which makes our rather simple game much more interesting.</p> <p>Consider the following placement:</p> <p></p> <p>This hazard forces the player to either the left or right side of the road, and they will be given a group of points if they choose either path. However, if the player chooses the right path and they cut left directly after they clear the hazard, they can collect the points on the left side without taking damage from the hazard.</p> <p>Here is another scenario:</p> <p></p> <p>In this placement, the three orange pick ups are unreachable without hitting a hazard zone. However, it is actually worthwhile to lose one or two missiles by cutting through the hazard volume in order to pick up the nine points from the orange group.</p> <p>It is even worth it when you factor in the opportunity cost of missing the group of four yellow pick ups on the left side, which is what would conventionally seem more appealing.</p> <p>The interaction between these two game elements is much more engaging than they are individually. Designing game mechanics which play off of each other synergistically is a great way to do more with less- which is a great principle to stride towards when you are doing indie development!</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#3-gamemanager","title":"3) GameManager","text":"<p>When we want to reset or exit our game, we simply exited and entered Play Mode to reset the scene. This is not a good solution for when our game is built though, as the player would be unable to close the game and would need to re-open it every time they lose!</p> <p>We will make a pretty brief script that will allow the player to reload the scene and exit the game on demand.</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#add-new-controls","title":"Add New Controls","text":"<p>We will want to create two input actions for this control. Space will reset our game and Escape will quit.</p> <p>Using the project window, open the Input Actions assets we created a while ago to map player input. Select the Player Action Map and create a Reset and Quit action, bound to Space and Escape respectively (Use the +v button to add a new binding, and set the path to the desired button).</p> <p>Again, do not forget to hit the Save Asset button!</p> <p></p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#gamemanager","title":"GameManager","text":"<p>First, in your Scenes folder in the Project window, rename the SampleScene to Main, which is a better name for our main scene.</p> <p>To the scene, create a new empty object (not under the Environment GameObject) and name it Game Manager. You will also need to add a <code>PlayerInput</code> component and set the <code>Actions</code> property to your Input Actions asset.</p> <p>Create a script <code>GameManager</code> and attach it to the Game Manager as a component.</p> GameManager.cs<pre><code>using UnityEngine;\nusing UnityEngine.InputSystem;\nusing UnityEngine.SceneManagement;\n\n[RequireComponent(typeof(PlayerInput))]\npublic class GameManager : MonoBehaviour\n{\n    private void ResetLevel()\n    {\n        SceneManager.LoadScene(\"Main\");\n    }\n\n    private void QuitGame()\n    {\n        Application.Quit(0);\n    }\n\n    private void OnReset(InputValue inputValue) =&gt; ResetLevel();\n    private void OnQuit(InputValue inputValue) =&gt; QuitGame();\n}\n</code></pre> Abstract <p>The <code>UnityEngine.SceneManagement</code> allows us access to the <code>SceneManager</code>, which enables usage of the <code>SceneManager</code> which can load scenes. In the <code>ResetLevel</code> method, we simply tell it to load the Main scene, which will essentially reload the level from scratch.</p> <p>The <code>QuitGame</code> method does exactly that- closes the application with an exit code of 0 (An OK status code).</p> <p>Both of those methods are invoked by a Input Action response method <code>OnReset</code> or <code>OnQuit</code>. Note that you could just execute those two calls in the Input Action response bodies themselves, but it is usually better practice to just have them call methods instead.</p> <p>If you enter Play Mode, you can now use Space to reset the level. Quitting will not work in Play Mode, however!</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#4-creating-a-build","title":"4) Creating a Build","text":"<p>The last thing we need to do is make a build of our game so that it can be shared!</p> <p>In the top right of the Unity Editor, select <code>File &gt; Build Settings</code>. Ensure that your Main scene shows up in the scenes list and the platform selected is Windows, Mac, Linux, then select Build.</p> <p>A file selector will open to ask where you would like to build to, which begins one level above your Assets folder. Here, create a new folder called Builds, and a new folder within that called Rocket Runner 0.1.0, and select that as your build folder.</p> <p>Once it is done, you can open that folder to find your executable to run the game. The entire Rocket Runner 0.1.0 folder is what you would send or upload somewhere to share your game at this point!</p> <p>Note that when you are developing a larger project, you should test builds of your game somewhat frequently, do not wait until you are finished to test your builds for the first time!</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#conclusion","title":"Conclusion","text":"<p>Congratulations, you've finished this pretty lengthy tutorial! \\o/</p> <p>Even though our game looks pretty simple on the surface, you have actually learned some good stuff to springboard you into your own projects:</p> <ul> <li>Physics and non-physics driven movement</li> <li>Collider and trigger use and event response</li> <li>Work on some more complex, composited GameObjects</li> <li>Using Actions to create custom events</li> <li>World-space user interfaces</li> <li>Some vector maths practice</li> </ul>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#where-do-i-go-from-here","title":"Where Do I Go From Here?","text":"<p>Game Development is a deeply practice driven discipline. Before you start working on your dream projects, find long-form guides that can bring you through the process of building a whole, small game, not just a couple features. At the end of the day, your ability to make good games will depend on your knowledge of the entire game-making process, so absorbing a good volume of comprehensive guides will make you a strong developer more so than anything when you are starting out.</p> <p>Full video games can easily become some of the most complicated pieces of software you will ever work on, so do not be surprised to find out that gaining proficiency will be a slow process that will take a lot of time and dedication. The best thing you can do is pace yourself and set a schedule of time dedicated to it!</p>"},{"location":"tutorials/unity-tutorials/first-step-series/unity-runner-1/#what-else-is-there-here-for-me","title":"What Else Is There Here For Me?","text":"<p>I very particularly made Rocket Runner to be a game which can be expanded in many different ways. It is a good baseline by which many improvements could be made- all of which would be individual tutorials all on their own. Some examples of improvements that could be made are as follows:</p> <ul> <li>We could turn our game into an endless runner by procedurally generating new road segments. The difficulty could be ramped up as time goes along.<ul> <li>This would be a major improvement towards making it into a very solid game. Definitely come back to this project and give this a try if nothing else once you have more experience.</li> </ul> </li> <li>Many, many visual effects could be added:<ul> <li>Missile explosion particle effects.</li> <li>Particle or debris effects when the Player or Kill Walls are destroyed.</li> <li>Point PickUps could be made prettier, turned into orb-like pick ups.</li> <li>Trails on missiles, as well as making them fly at Kill Walls in a more interesting pattern.</li> <li>A better looking skybox and some lighting effects.</li> </ul> </li> <li>Sound effects could be added to movement, explosions, and missile firing. Some music would be nice too.</li> <li>A main menu and pause screen would make the game a bit less clunky. Maybe a leaderboard for distance traveled too?</li> </ul> <p>Ideally in the future, this tutorial will be expanded to tackle some of the above improvements in some additional modules.</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/","title":"Fall 2024 Game Jam Template - Base Tutorial","text":"<p>By Marceline Gallegos and Jake Rogers</p> <p>Created: February 7th, 2024</p> <p>Updated: September 18th, 2024</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#summary","title":"Summary","text":"<p>Since the GDL already has articles on the basics of Unity use, we will not repeat ourselves here. Please view the articles below if you are stuck with the following topics:</p> <ul> <li>Installing Unity (Read: Tutorial Here!)</li> <li>Basic Editor Controls (Read: Tutorial Here!)</li> </ul> <p>Please also note, most images and gifs on this page can be viewed in full size by Right-Clicking them and selecting 'Open Image in New Tab'. Please do so if they are hard to read.</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#chapter-1-project-set-up","title":"Chapter 1: Project Set-Up","text":"<p>Visit this project's GitHub Page and follow the instructions to download the starting template. </p> <p>Be sure to select the 'base-template' branch before cloning or downloading the ZIP.</p> What's in the Box? <p>The starting template comes preconfigured with initialized packages and art assets to make syncing up with the tutorial as painless as possible.</p> <p>For your information when you start making your own projects, we've included the following:</p> <ol> <li>A Unity Project using the 2D URP template.</li> <li>The Unity Input System Package.</li> <li>Initialized Text Mesh Pro (TMP), with the extra options for additional fonts.</li> <li>Various Art and UI assets for later modules and experimentation.</li> </ol> <p>Everything else is up to you to make. Fun!</p> <p>Once you have the project open in Unity, take a brief second to regenerate your project files for Visual Studio. This is done by selecting along the top <code>Edit -&gt; Preferences... -&gt; External Tools -&gt; External Script Editor -&gt; Visual Studio 2022 / 2019</code>. </p> <p>Then, press the 'Regenerate project files' button.</p> <p></p> Why Did I Need to do That? <p>Some files that Visual Studio uses to provide many contextual coding features are often not uploaded to source control systems, so they won't be included when you clone or download from a repository.</p> <p>Therefore, it is usually a good idea (unless told otherwise) to regenerate these project files when you first download a repository before you wonder why everything looks broken in Visual Studio!</p> <p>Lastly, whenever you download a new Unity project, Unity typically doesn't know what scene it should open, so you'll wind up on an empty, unsaved one. Before continuing, open the <code>Scenes</code> folder in the Project window and open the SampleScene.</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#chapter-2-scene-and-art","title":"Chapter 2: Scene and Art","text":"<p>In this chapter, we will get warmed up with the Unity Editor by building the Game Objects for what will eventually be our Player and Enemies. We'll also make quick use of our art assets so we have something pretty to look at.</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#adding-the-background","title":"Adding the Background","text":"<p>The default grey background is pretty ugly, so let's pull in our background art to quickly remedy that.</p> <p>In the project window, find <code>Art -&gt; Backgrounds -&gt; darkPurple</code>. This is a tilable PNG background which we can use to cover the entire screen space. Drag the darkPurple image asset into an empty space on the Hierarchy window to add it to the scene (ensure it hasn't been made a child of anything else).</p> <p>If you were to try and resize the sprite using the Scale or Rect tool, you'll notice that it just stretches and distorts, which looks terrible. Instead, we must tile the sprite to allow it to repeat across a region instead of stretching.</p> <p>To do so, select the new sprite we added to the Hierarchy to view it in the Inspector. Make the following changes:</p> <ul> <li>Draw Mode: Tiled<ul> <li>Size, Width: 35</li> <li>Size, Height: 35</li> </ul> </li> </ul> <p>This will accomplish the desired tiling effect, which looks much better than stretching it! Let's also rename the Game Object from 'darkPurple' to 'Background'.</p> <p>Lastly, you may have noticed that the background's Inspector window is displaying a warning about the sprite's Mesh Type. We'll resolve this by doing exactly what it says: Select the <code>Art -&gt; Backgrounds -&gt; darkPurple</code> asset in the Project window and change the Mesh Type to 'Tiled', then hit apply.</p> <p></p> <p>Note that you can of course use any of the other backgrounds provided if you like them more, and you can also select the sprite Game Object and change it's Color property to tint them as well!</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#creating-the-enemy-and-player-game-objects","title":"Creating the Enemy and Player Game Objects","text":"<p>Let's take a moment to discuss exactly what our player and enemies will do. </p> <p>Our enemies are simple, they will...</p> <ul> <li>Float across the playable area in a single direction.</li> <li>Upon colliding with the Player, destroy both the Player and themselves.</li> </ul> <p>Our Player will be slightly more complicated:</p> <ul> <li>Fly around in any direction using the WASD keys, coming to a stop with no input.</li> <li>Rotate towards the direction it is flying in.</li> <li>Shoot lasers which can destroy enemies.</li> </ul> <p>While we're on the topic of pulling in our art, let's set up the visuals and initial Game Objects for the enemies and Player right now.</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#player","title":"Player","text":"<p>Start by Right-Clicking on the Hierarchy window and selecting 'Create Empty'. Name the new Game Object 'Player'. </p> <p>We'll then add a empty Game Object to the Player. Do this by right-clicking Player and 'Create Empty' on that. Name the new child object 'Visuals'</p> <p>Lastly, we'll add a sprite the Visuals object which will be our graphics for the Player. Right-Click on Visuals and do <code>2D Object -&gt; Sprite -&gt; Square</code>. Name it Base Sprite. </p> <p>On Base Sprite, we can use whatever sprite we would like for our player by dragging it into the <code>Sprite</code> field. You can find a bunch of very suitable candidates in <code>Art -&gt; Sprites</code> within the Project window. I'll be using playerShip2_red.</p> Selecting Reference Types <p>In addition to supporting drag-and-drop, reference-type fields will often allow you to press the circular-selector button to see all items in the project that can fill in the field, which you can then search from. </p> <p>This is often a much faster way to fill in things from the inspector if you don't have them already visible in the Project window!</p> <p></p> <p>You may have noticed an issue here, which is that the Player sprite appears to be drawing underneath the background, thusly making it not visible (This may or may not occur depending on a couple of factors, but it needs to be fixed regardless).</p> <p>To fix this, we need to set up Sprite Sorting Layers which define what groups of sprites should render on top of others. Fold out the Layers drop down button in the top-right of the editor, and select 'Edit Layers'.</p> <p>You can then fold down the Sorting Layers list and press the <code>+</code> button to add a few more. I'll be using the following layers in this specific order:</p> <ul> <li>0) Background</li> <li>1) Default</li> <li>2) Projectile</li> <li>3) Enemy</li> <li>4) Player</li> </ul> <p>Things at the bottom of the list will always render in front of things closer to the top of the list.</p> <p>Select the Background and change the Sprite Renderer's <code>Sorting Layer</code> to <code>Background</code>. Change the Player's Base Sprite's <code>Sorting Layer</code> to <code>Player</code>. There should be no rendering conflicts now!</p> <p></p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#enemy","title":"Enemy","text":"<p>We've got a great opportunity to be lazy here. Let's duplicate the Player Game Object (select it and press Ctrl+D), then rename it to 'Enemy'. You can then change its Base Sprite's <code>Sprite</code> to one of the asteroid sprites. I'll be using <code>Art -&gt; Sprites -&gt; meteorBrown_big1</code>.</p> <p>Don't forget to change sorting layer for the enemy's base sprite to <code>Enemy</code> instead of <code>Player</code>. Also, move the Enemy a bit below the Player (but still on screen) so that they aren't overlapping.</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#chapter-3-enemy-scripts","title":"Chapter 3: Enemy Scripts","text":"<p>In order to get our enemies to do exactly what we want them to, we'll need to write custom scripts to dictate what they should do when the game runs through code. Since the design goals for the Enemy are much simpler than for the Player, we'll start on the Enemy.</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#component-set-up","title":"Component Set Up","text":"<p>Before we write our own script, we'll need to do a little more configuration on the Enemy Game Object before hand.</p> <p>To start, whenever we want to allow a Game Object to move in anything besides the most simple of ways, we generally want to add a Rigidbody (Or Rigidbody2D if you're using 2D, which we are!) component. Doing so allows the Game Object to do the following:</p> <ul> <li>Move at run time using the Unity Physics System and be affected by various kinematic forces.</li> <li>Register collisions with other Rigidbodies.</li> </ul> <p>We would like to do both of those, so select the Enemy Game Object and do <code>Add Component -&gt; Rigidbody2D</code>.</p> <p>If you enter play mode immediately after doing so, you'll actually notice your enemy fall off the screen due to the implicit gravity force that Rigidbody2D's come initialized with!</p> <p>We don't really want gravity here though. In fact, we would like to have very explicit control over how our enemy moves (In other words, we don't want the physics engine doing anything to it unless we code it that way). Fortunately, changing the Rigidbody2D's <code>Body Type</code> property to <code>Kinematic</code> in the Inspector will do exactly that- the Enemy will no longer be affected by gravity or bounced around by other objects. Cool.</p> <p>Before we continue, we do still need to add a Collider to this Game Object configured to be a Trigger so that we can tell when it hits the Player. Do <code>Add Component -&gt; Circle Collider</code> to do so. Check the <code>Is Trigger</code> property, and press the <code>Edit Collider</code> button to change the hitbox to your liking (or use the <code>Radius</code> property to numerically change the size).</p> <p></p> <p>Note: The <code>Enemy -&gt; Circle Collider 2D -&gt; Is Trigger</code> property should be checked in the screenshot above, sorry!</p> <p>Great! That's all the set up we need to start scripting!</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#enemycontroller-script","title":"EnemyController Script","text":"<p>Let's now build the script that will add our custom behavior for these Enemies. In the Scripts folder within the Project window, Right-Click and do <code>Create -&gt; C# Script</code>, name it 'EnemyController' and double-click to open it in your code editor.</p> <p>Once we are done writing this script, we will be able to place it onto our Enemy Game Object as a component (just like the Rigidbody2D and Sprite Renderer) to apply the custom behavior.</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#movement","title":"Movement","text":"<p>For now, we'll write the following code in <code>EnemyController.cs</code>:</p> EnemyController.cs<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class EnemyController : MonoBehaviour\n{\n    private Rigidbody2D _rigidbody;     // The rigidbody component on this enemy\n\n    // Start is called before the first frame update\n    void Start()\n    {\n        _rigidbody = GetComponent&lt;Rigidbody2D&gt;();\n\n        _rigidbody.velocity = new Vector2(0f, 5f);\n    }\n}\n</code></pre> Abstract <p>Every script which derives from the <code>MonoBehavior</code> class will have a series of Events called on it at various times by Unity's script runner or other activites in your game. <code>void Start()</code> is one such Event- and the code within it starts once the Game Object the script is attached to enters the scene for the first time (which will be when the game starts for any object already in the scene). This makes it a good place for initialization.</p> <p>To get our Enemy to move, we need to set the velocity on its Rigidbody2D component we attached through code- it'll fly in whatever direction we specify.</p> <p>Therefore, when the game starts, we use <code>GetComponent&lt;Rigidbody2D&gt;()</code> (Line 7) to search for the Rigidbody and store a reference to it- then set it's velocity to an upwards-pointing vector (0 on the X axis, 5 on the Y).</p> <p>Return back to Unity and attach the new <code>EnemyController</code> component to the Enemy Game Object, then enter play mode to watch it fly off the top of the screen!</p> <p></p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#movement-adjustments","title":"Movement Adjustments","text":"<p>There two things we would like to change about how we move the Enemy. First- in order to change the Enemy's speed, we currently have to go back into the code, change it, and recompile it. Not only is this a hassle, but it also means all enemies have to move at the same speed, which is very inflexible.</p> <p>To fix this, make the following adjustments to the code: EnemyController.cs<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class EnemyController : MonoBehaviour\n{\n    [SerializeField, Tooltip(\"The enemy's movement speed in units per second\")]\n    private float _movementSpeed = 2f;\n\n    private Rigidbody2D _rigidbody;     // The rigidbody component on this enemy\n\n    // Start is called before the first frame update\n    void Start()\n    {\n        _rigidbody = GetComponent&lt;Rigidbody2D&gt;();\n\n        _rigidbody.velocity = new Vector2(0f, _movementSpeed);\n    }\n}\n</code></pre></p> Abstract <p>Adding the new class member <code>_movementSpeed</code> and putting the <code>SerializeField</code> attribute before it allows this value to be set in the Inspector window- so we can adjust it in the editor (even while the game is playing)!</p> <p>We then use that <code>_movementSpeed</code> in place of the hard-coded <code>5f</code> speed.</p> <p>Note that the <code>Tooltip('...')</code> attribute helps tell us what the proceding class member is used for- both here and  when we hover over that property in the Inspector.</p> <p>If you go back to the editor and look at the Inspector for Enemy, you will see a new <code>Movement Speed</code> field which you can type custom values into. As mentioned in the Abstract, you can even adjust this value while in play mode!</p> <p>The second issue we'd like to fix is that currently, the enemies will only ever move in the up direction (positive on the Y axis, assuming <code>Movement Speed</code> is positive). As you may have noticed in the thumbnail, we have enemies moving in any kind of direction, so let's fix that!</p> <p>For this game, we use any projectile's Y-Axis (The green one, colloqually the Up Axis in 2D) as it's forward direction. Therefore, our Enemy's velocity should travel in that direction.</p> How Can I Tell What Direction a Game Object is 'Facing'? <p>In the Editor, select a Game Object, then ensure your rotation mode (Located in the top left of the Scene window, next to the tool shelf) is set to <code>Local</code>, not <code>Global</code>. </p> <p>You can then select the Move Tool in the Scene window to look at the direction of the Green arrow to see the orientation of the object.</p> <p>You can rotate the Game Object to observe this Up-arrow change direction.</p> <p></p> <p>This is a lot simpler to do than it probably sounds, and just involves changing one line: To fix this, make the following adjustments to the code: EnemyController.cs<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class EnemyController : MonoBehaviour\n{\n    [SerializeField, Tooltip(\"The enemy's movement speed in units per second\")]\n    private float _movementSpeed = 2f;\n\n    private Rigidbody2D _rigidbody;     // The rigidbody component on this enemy\n\n    // Start is called before the first frame update\n    void Start()\n    {\n        _rigidbody = GetComponent&lt;Rigidbody2D&gt;();\n\n        _rigidbody.velocity = transform.up * _movementSpeed; // Set the linear velocity of this enemy in units per second.\n    }\n}\n</code></pre></p> Abstract <p><code>transform.up</code> provides a directional Vector which matches the Green arrow of the Game Object the script is attached to. We can then multiply that Unit Vector by our <code>_movementSpeed</code> to make it move according to our desired speed.</p> <p>For example, now if our enemy is pointed towards the right, the velocity will be set to <code>(1, 0) * 2</code>, rather than <code>(0, 1) * 2</code>. Similarly, if it's pointed diagonally down and to the left, it will be <code>(-0.71, -0.71) * 2</code>.</p> <p>Note that you can get the direction for any of the local axes via <code>transform.right</code> and <code>transform.forward</code> (3D). You can also set them to a particular value to align the Game Object's axis with the direction you provide, which is VERY USEFUL.</p> <p>As a side note, don't be put off if the talk of Vectors and Directions is a little lost on you- it can take a moment for it to click into place for some. If it doesn't come naturally, feel free to look up some supportive information- this article from Unity is a good start:</p> <p>Unity's Vector Cookbook</p> <p>(Note that these pages report as legacy, but all information is valid since it's mathematics. Be sure to use the <code>-&gt;</code> buttons to view additional pages)</p> <p>Anyways, rotate your Game Object to change it's up direction and play it will now travel in the correct direction!</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#destroying-the-player","title":"Destroying the Player","text":"<p>We will modify our <code>EnemyController</code> script to do the following:</p> <ol> <li>Watch out for any objects entering the enemy's trigger collider.</li> <li>Upon a trigger collision, check to see if the thing we collided with is the Player.</li> <li>If so, destroy both of us.</li> </ol> <p>Let's implement that with the following code on <code>EnemyController</code>: EnemyController.cs<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class EnemyController : MonoBehaviour\n{\n    [SerializeField, Tooltip(\"The enemy's movement speed in units per second\")]\n    private float _movementSpeed = 2f;\n\n    private Rigidbody2D _rigidbody;     // The rigidbody component on this enemy\n\n    // Start is called before the first frame update\n    void Start()\n    {\n        _rigidbody = GetComponent&lt;Rigidbody2D&gt;();\n\n        _rigidbody.velocity = transform.up * _movementSpeed; // Set the linear velocity of this enemy in units per second.\n    }\n\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        Destroy(collision.gameObject);\n        Destroy(gameObject);\n    }\n}\n</code></pre></p> Abstract <p><code>void OnTriggerEnter2D(Collider2D)</code> is another Unity Event- this one will run whenever another collider enters the Trigger Collider present on this Game Object (with the <code>collision</code> parameter being the other collider detected).</p> <p>Quite simply, we will use the <code>Destroy(GameObject)</code> method to destroy the other thing we collided with, then Destroy ourselves.</p> <p>You will need to add a <code>Rigidbody2D</code> and <code>CircleCollider</code> to the Player in order to register collisions against it. Configure both components the exact same way as you did on the Enemy.</p> <p>Note, however, that the code above will cause the enemy to destroy any thing is collides with, not just the Player.</p> <p>There are a couple ways to determine if the thing we collided with is a particular Game Object we're looking for, but the most common way is to check to see if it has a particular component unique to Player.</p> <p>In Chapter 4, we'll need to add a <code>PlayerController</code> to our Player, so let's go ahead and do that now so that we can search for that component while doing collsion resoluton.</p> <p>In the Project Window, make a new <code>PlayerController</code> C# Script, add it as a component to the Player (we do not need to edit the script yet), then make the following changes to <code>EnemyController</code>: EnemyController.cs (fragment)<pre><code>private void OnTriggerEnter2D(Collider2D collision)\n{\n    // On collision with another game object, check if it's the player.\n    // If so, destory it and this enemy.\n    if (collision.GetComponent&lt;PlayerController&gt;() != null)\n    {\n        Destroy(collision.gameObject);\n        Destroy(gameObject);\n    }\n}\n</code></pre></p> Abstract <p>Upon hitting another collider, we'll search its Game Object to see if it has a <code>PlayerController</code> component. Since <code>GetComponent</code> will return <code>null</code> if it cannot find the type searched for, we can check against that.</p> <p>If a <code>PlayerController</code> is found, then we can procede with destroying the Player and the Enemy.</p> <p>If you'd like, you can confirm this works by Ctrl+D duplicating the Enemy, rotating them to collide with one another, and witnessing them pass through one another harmlessly!</p> <p></p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#chapter-4-player-scripts","title":"Chapter 4: Player Scripts","text":"<p>The script for the Player will be a little more complicated, but now that we've covered the basics with the Enemy, we can just focus on the new details. Let's work on getting the Player moving using the User's input!</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#input-actions-set-up","title":"Input Actions Set-Up","text":"<p>Before we write our script, we have to create an Input Actions asset which will describe how our user will interact with the game.</p> <p>In short, an Input Actions asset contains a list of Actions, each with one or more Bindings which trigger them. Scripts can hook into Actions in order to respond to and read data from any time it is triggered.</p> <p>Fortunately, Unity has a shortcut to make a pre-configured Input Actions asset which will have all of the Actions and Bindings we'll need. We'll take advantage of this now.</p> <p>Select the Player Game Object and add a Player Input component. Below the <code>Actions</code> property, press the Create Actions... button and save the asset it offers to create.</p> <p></p> <p>The Input Actions editor will open up (you can double-click the newly made asset in the project window if you lost it). You can see that it has created a mapping with the following Actions:</p> <ul> <li>Move<ul> <li>Generates a 2D Input Vector using the WASD (A-D for X, W-S for Y) keys OR the controller left joystick.</li> </ul> </li> <li>Look<ul> <li>Creates a 2D Input Vector using the Mouse Delta OR controller right joystick (Irrelevant to us).</li> </ul> </li> <li>Fire<ul> <li>Triggered with a Left Mouse Button click or controller Right Trigger press.</li> </ul> </li> </ul> <p></p> <p>The <code>Move</code> Action will produce a 2D Vector (X, Y) we can use from the Player's Input. For example, if the player is holding the W key, it will return (0, 1) for up. It would also return (-0.71, 0.71) if they were holding the W &amp; A (The result is normalized to create a direction Vector).</p> <p>While we could go into more detail about building actions and bindings from scratch, we want to keep things simple. We will touch on creating new actions and bindings in future modules.</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#playercontrollercs","title":"PlayerController.cs","text":"<p>In Chapter 3, we attached an empty <code>PlayerController.cs</code> script (as well as a Rigidbody2D and a Circle Collider) to the Player. We will now fill out that script here.</p> <p>Before we start, some explaination on the <code>Player Input</code> component is in order. In short, it listens for any Action to be triggered from the Input Actions it is watching, and then sends a message to every MonoBehavior script on the same Game Object as itself. Any component that receives this message can successfully respond to it if it has a function that matches the method's signature.</p> <p>You can see which Actions will be messaged out in the info box at the bottom of it's inspector shelf- it has one for each Action, following the pattern <code>On&lt;ActionName&gt;</code>. Therefore, if we wanted to catch the <code>OnMove</code> action, our script will need a <code>void OnMove(InputValue value)</code>.</p> <p></p> <p>Let's capture that data and print it out to ensure it's working. Make the following edits to <code>PlayerController.cs</code>: PlayerController.cs<pre><code>using UnityEngine;\nusing UnityEngine.InputSystem;\n\npublic class PlayerController : MonoBehaviour\n{\n    // Start is called before the first frame update\n    void Start()\n    {\n\n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n\n    }\n\n    private void OnMove(InputValue movementValue)\n    {\n        Debug.Log(movementValue.Get&lt;Vector2&gt;());\n    }\n}\n</code></pre></p> Abstract <p>Ensure you don't miss line 2, which includes the <code>InputSystem</code> namespace into this file.</p> <p>As mentioned before, the <code>OnMove</code> function will called by a broadcasted message sent from the <code>Player Input</code> component, which may seem obtuse if you're not used to messaging systems. The message contains a <code>InputValue</code> object which contains a bunch of information about the Action that was performed.</p> <p>Primarily, we care to retrieve the value of it using the <code>Get</code> method (which must be casted to a <code>Vector2</code>, which is what we are expecting to get out of the <code>Move</code> action as dictated in the Input Actions asset).</p> <p>Also, be sure that the <code>void OnMove(InputValue movementValue)</code> function signature is EXACTLY correct- the message will not be caught if the script does not have a matching function signature.</p> <p>Enter Play Mode and use either your WASD keys or a controller's Left Joystick- you'll notice your inputs are being logged to the Console window!</p> <p>Now that we have access to the user's movement input within this script, we can use that to allow the Player to move under our control!</p> <p>... But you actually know everything you need in order to make that work yourself from working on the <code>EnemyController</code>. Try implementing this yourself! Here are two hints:</p> <ol> <li>You will need to store the <code>movementValue.Get</code> results into a member-level variable to make it accessible by other functions within the script. You can create a <code>private Vector2 _movementInput = Vector2.zero</code> variable within the <code>PlayerController</code> to do this.</li> <li>Instead of using the <code>Start</code> method, you will actually want to handle updating the velocity in the <code>FixedUpdate</code> method (Just add <code>Fixed</code> in front of the <code>Update</code> method in the script).</li> </ol> <p>Fold out the Admonition below to see our answer after you've given it a shot:</p> Solution PlayerController.cs<pre><code>using UnityEngine;\nusing UnityEngine.InputSystem;\n\npublic class PlayerController : MonoBehaviour\n{\n    [SerializeField, Tooltip(\"The player's movement speed in units per second.\")]\n    private float _movementSpeed = 5f;\n\n    private Rigidbody2D _rigidbody;\n    private Vector2 _movementInput = Vector2.zero;\n\n    void Start()\n    {\n        _rigidbody = GetComponent&lt;Rigidbody2D&gt;();\n    }\n\n    // Frame-rate independent. Used for physics calculations.\n    void FixedUpdate()\n    {\n        _rigidbody.velocity = _movementInput * _movementSpeed;\n    }\n\n    // Unity sends a message to this function whenever it detects input from anything bound to the \"Move\" action.\n    // Grab the target vector from the input value and store it for use in fixed update.\n    private void OnMove(InputValue movementValue)\n    {\n        _movementInput = movementValue.Get&lt;Vector2&gt;();\n    }\n}\n</code></pre> <p>Instead of just using the Object's up direction to move, we use the Input direction instead (still multiplying it by a speed!), which we store in a member variable to make it accessible to the entire class.</p> <p>FYI, the <code>void Update</code> method is another Unity Event method, which is called continuously per each frame of your game. If you imagine your game running at 60 Frames Per Second, whatever code is within the <code>void Update</code> method would then be called 60 times a second, making it good for runtime code.</p> <p>The <code>void FixedUpdate</code> method will be triggered 50 times a second, no matter how fast (or slow) the game is running. This consistent timestep makes it very useful for physics calculations, so Unity puts all of it's Physics processing on those timesteps. You should too to ensure better physics stability.</p> <p>This looks a little goofy though, so let's also rotate the Player in the direction that it's currently moving in. Making the following change to <code>void FixedUpdate()</code>:</p> PlayerController.cs (fragment)<pre><code>...\nvoid FixedUpdate()\n{\n    _rigidbody.velocity = _movementInput * _movementSpeed;\n\n    if (_movementInput != Vector2.zero) // Avoid rotating the player to an upward resting position when not moving.\n    {\n        transform.rotation = Quaternion.LookRotation(Vector3.forward, _movementInput);\n    }\n}\n...\n</code></pre> Abstract <p>The <code>Quaternion.LookRotation()</code> method gets a rotation from a direction, so we change the Player's direction to the input direction.</p> <p>Note that the first parameter to <code>LookRotation</code> is the axis that the rotation occurs on. For 2D games, this will always be <code>Vector3.forward</code>, which aligns with the 'Topdown' Z-axis, or the direction our camera is viewing the game plane on.</p> <p><code>Quaternion.LookRotation</code> will give us an anomlous result if the input vector we pass is zero, so we use an <code>if</code> to avoid running it if the player is not providing input at this time!</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#smoother-movement","title":"Smoother Movement","text":"<p>Right now, our movement and rotation is instantaneous, which doesn't look too appetizing. With a bit more effort, we can smooth it out to really improve the game feel of our Player Controller.</p> <p>Add the following changes:</p> PlayerController.cs<pre><code>...\npublic class PlayerController : MonoBehaviour\n{\n    [SerializeField, Tooltip(\"The player's movement speed in units per second.\")]\n    private float _movementSpeed = 5f;\n\n    [SerializeField, Tooltip(\"Amount of smoothing time applied to velocity changes\")]\n    private float _movementSmoothingTime = 0.35f;\n\n    [SerializeField, Tooltip(\"The player's angular rotation speed in degrees per second.\")]\n    private float _rotationSpeed = 500f;\n\n    private Rigidbody2D _rigidbody;\n    private Vector2 _movementInput = Vector2.zero;\n    private Vector2 _currentMovement = Vector2.zero;\n    private Vector2 _movementSmoothingVelocity = Vector2.zero;\n\n    void Start()\n    {\n        _rigidbody = GetComponent&lt;Rigidbody2D&gt;();\n    }\n\n    // Frame-rate independent. Used for physics calculations.\n    void FixedUpdate()\n    {\n        // Gradually changes a vector towards a desired target over time.\n        // Used to smooth player movement to avoid abrupt, jittery movement.\n        _currentMovement = Vector2.SmoothDamp(\n            _currentMovement,                   // Our current velocity\n            _movementInput,                     // The player's input, we want to *reach* this\n            ref _movementSmoothingVelocity,     // our current *acceleration*\n            _movementSmoothingTime              // smoothing duration, lower is faster.\n        );\n        _rigidbody.velocity = _currentMovement * _movementSpeed; // Set the linear velocity of the player in units per second.\n\n        if (_movementInput != Vector2.zero) // Avoid rotating the player to an upward resting position when not moving.\n        {\n            Quaternion targetRotation = Quaternion.LookRotation(Vector3.forward, _currentMovement);\n\n            // Gradually rotate the player towards the direction of movement.\n            // Used to smooth player rotation to avoid abrupt, snappy turns.\n            transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, _rotationSpeed * Time.fixedDeltaTime); // Set the player's rotation.\n        }\n    }\n\n    ...\n\n}\n</code></pre> Abstract <p>Smoothing out some kind of motion generally involves doing the following:</p> <ol> <li>Find some Target Value that we'd like to reach (In this case, matching the rigidbody velocity to the player input).</li> <li>Accelerate our Current Value TOWARDS the Target Value over time.</li> <li>Use the Current Value as the acting value as it tries to reach the Target Value.</li> </ol> <p>In our circumstance, we create a sort of intermediary <code>_currentMovement</code> vector which tries to \"catch up\" to the <code>_movementInput</code> each Fixed Update using the <code>SmoothDamp</code> method.</p> <p>We also linearly rotate the the Player towards the <code>_currentMovement</code> direction as well to smooth out the rotation.</p> Smoothing Types <p>Note that there are multiple ways of smoothing a value, and it's important to note them.</p> <ul> <li>Linear Acceleration (or MoveTowards). This type adds a flat increment to the Current Value each step until it reaches the Target Value.</li> <li>Linear Interpolation (Lerp). This smoothing method will move the Current Value some percentage of the distance between itself and the Target Value every step. This creates a motion which starts off very fast, but slows down as it reaches the target.</li> <li>Smooth Damp. This rather complex smoothing algorithm aims to simulate spring-motion. It can 'appear' to work a lot like Lerp, but has much better fidelity and fluidity at the cost of being a little more annoying to set up.</li> </ul> <p>You should now notice your Player is significantly smoother and more satisfying to control. You can play around with the <code>PlayerController: _movementSmoothingTime</code> in the inspector to change the feel- larger values will make the player feel heavier to turn and generally less agile, lower numbers will be snappier.</p> <p></p> <p>In case you forgot, our game is gamepad compatible. Plug in a controller to see even finer control!</p> <p>Don't worry if the math behind smoothing is a litle daunting right now. You will absolutely have more opportunities to practice it in your future projects- much like Vector mathematics, it's ubiquitous across almost all parts of making games feel good.</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#chapter-5-laser-gun","title":"Chapter 5: Laser Gun","text":"<p>In this chapter, we'll create the feature which allows the player to fire lasers that can destroy enemies. This will serve as our introduction to Instantiating (or spawning) Game Objects while the game is playing- a vital component of making games.</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#laser-prefab","title":"Laser Prefab","text":"<p>To start, we will create a Laser Prefab- a premade Game object we can clone copies of. </p> <p>Our lasers will work very similarly to the enemies- travel in a straight line, but kill enemies instead of the player! Aside from that minor detail, they will be almost identical in terms of scripting and components.</p> <p>You can see where this is going, let's be lazy again! Ctrl+D duplicate the Game Object, and the remove the <code>Enemy Controller</code> component (using the three dots icon in it's drawer on the inspector). Also rename the object to 'Laser Projectile'.</p> <p>Change the Base Sprite's sprite to one of the assets that resemble a laser. We're using <code>Art -&gt; Sprites -&gt; Lasers -&gt; laserRed01</code>. Change the <code>Sorting Layer</code> to <code>Projectile</code>.</p> <p>To turn this Laser Projectile into a prefab, open the Prefabs folder in the Project window, then Drag and Drop the Laser Projectile Game Object from the Inspector into the empty space within the Project window.</p> <p></p> Editing Prefabs <p>Note that once you create a Prefab, you can open up the Prefab for editting by double clicking it in the Project window.</p> <p>If you make changes to an INSTANCE of a prefab in a scene, those changes will not apply to the prefab (and thusly any copies made from it), it will only apply to that single instance.</p> <p>Again, just be sure that you double click the prefab to open it up in isolation to edit the prefab itself to avoid confusion. If you do make edits to a prefab instance and want to apply it to the Prefab itself, you can use the Overrides dropdown in the Inspector window on the instance and apply the changes. </p> <p>... Did you remember to remove the <code>EnemyController</code> component from the new Laser object? Okay, good!</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#laser-projectile-script","title":"Laser Projectile Script","text":"<p>As mentioned before, our Laser script will be nearly identical to the EnemyController, we just need to change the Component we check against to <code>EnemyController</code>.</p> <p>Create a <code>LaserProjectile.cs</code> C# script, attach it to the Laser Projectile PREFAB, and code up the following:</p> LaserProjectile.cs<pre><code>using UnityEngine;\n\npublic class LaserProjectile : MonoBehaviour\n{\n    [SerializeField, Tooltip(\"The projectile's movement speed in units per second\")]\n    private float _projectileSpeed = 10f;\n\n    private Rigidbody2D _rigidbody;\n\n    private void Start()\n    {\n        _rigidbody = GetComponent&lt;Rigidbody2D&gt;();\n\n        _rigidbody.velocity = transform.up * _projectileSpeed; // Set the linear velocity of this projectile in units per second.\n    }\n\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        // On collision with another game object, check if it's an enemy.\n        // If so, destory it and this projectile.\n        if (collision.GetComponent&lt;EnemyController&gt;())\n        {\n            Destroy(collision.gameObject);\n            Destroy(gameObject);\n        }\n    }\n}\n</code></pre> <p>If you place down a Laser Projectile now and aim it towards an Enemy (You can set the Enemy's <code>Movement Speed</code> to <code>0</code> to make this easier), it will destroy the enemy. Great!</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#player-laser-gun","title":"Player Laser Gun","text":"<p>Now we need to add a script that allows the user to spawn these lasers using user input. Recall that the Input Actions asset we had generated for us came with a <code>Fire</code> Action bound to Left Mouse Button and Right Trigger.</p> <p>Before we write the script, whenever we are making something which \"fires\" something, you generally want a dedicated Fire Point Game Object which the projectiles will come out from.</p> <p>Add an Empty Game Object to the Player (Called Fire Point), and position it so that it is located right at the tip of the ship's nose. Make sure the green-axis of the Fire Point is still pointed upwards, and we're good to go.</p> <p></p> <p>We'll do all of our weapon handling in a new script. Let's make one called <code>PlayerLaserGun.cs</code> and add it to the Player Game Object as a component:</p> PlayerLaserGun.cs<pre><code>    using UnityEngine;\n    using UnityEngine.InputSystem;\n\n    public class PlayerLaserGun : MonoBehaviour\n    {\n        [SerializeField, Tooltip(\"A game object to use as a projectile.\")]\n        private GameObject _projectilePrefab;\n\n        [SerializeField, Tooltip(\"Where to shoot projectiles from.\")]\n        private Transform _firePoint;\n\n        private void OnFire(InputValue buttonValue)\n        {\n            FireProjectle();\n        }\n\n        // Create a projectile object at the fire point's current position and rotation.\n        private void FireProjectle()\n        {\n            Instantiate(_projectilePrefab, _firePoint.position, _firePoint.rotation);\n        }\n    }\n</code></pre> Abstract <p>In order to instantiate a Prefab through code, we generally need two things:</p> <ol> <li>A reference to the Prefab asset.</li> <li>A position and rotation to instantiate the object with.</li> </ol> <p>We provide both using <code>SerializeField</code> attributed variables at the top of the file, which allows us to drag-and-drop the Prefab asset from the Project window and the Fire Point Game Object we created in the last step.</p> <p>This will spawn in a clone of the Laser Projectile prefab and their own script will send them flying away!</p> <p></p> <p>Once this is implemented and all fields are filled in, you can enter play mode and press the fire buttons to shoot lasers!</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#auto-fire","title":"Auto-fire","text":"<p>As you may have noticed, the user is capable of spamming the Fire action very quickly to shoot a ton of lasers. Let's add a limit to the number of lasers they can spawn and also make the weapon fire fully automatically for comfort.</p> <p>Make the following changes to <code>PlayerLaserGun.cs</code>: PlayerLaserGun.cs<pre><code>using UnityEngine;\nusing UnityEngine.InputSystem;\n\npublic class PlayerLaserGun : MonoBehaviour\n{\n    [SerializeField, Tooltip(\"A game object to use as a projectile.\")]\n    private GameObject _projectilePrefab;\n\n    [SerializeField, Tooltip(\"Where to shoot projectiles from.\")]\n    private Transform _firePoint;\n\n    [SerializeField, Tooltip(\"How frequently to shoot projectiles in seconds.\")]\n    private float _fireRate = 0.33f;\n\n    private float _fireTimer = 0f;\n    private bool _isReadyToFire = false;\n    private bool _isFireHeld = false;\n\n    void Update()\n    {\n        // A simple timer that works by subtracting the time between updates, or frames,\n        // from the timer variable, counting down from whatever the fire rate is.\n        if (_fireTimer &gt; 0f)\n        {\n            _fireTimer -= Time.deltaTime;\n        }\n\n        _isReadyToFire = (_fireTimer &lt;= 0f); // Once the timer counts down to zero, the projectile is ready to fire.\n\n        if (_isFireHeld &amp;&amp; _isReadyToFire)\n        {\n            FireProjectle(); // Create a projectile object.\n            _fireTimer = _fireRate; // Reset the timer.\n            _isReadyToFire = false;\n        }\n    }\n\n    // Unity sends a message to this function whenever the player presses or releases something bound to the \"Fire\" action.\n    // Store whether or not input's pressed to use in update.\n    private void OnFire(InputValue buttonValue)\n    {\n        _isFireHeld = buttonValue.isPressed;\n    }\n\n    // Create a projectile object at the fire point's current position and rotation.\n    private void FireProjectle()\n    {\n        Instantiate(_projectilePrefab, _firePoint.position, _firePoint.rotation);\n    }\n}\n</code></pre></p> Abstract <p>The first thing we do is capture whether or not the Fire button is held by reading the <code>isPressed</code> value.</p> <p>In the <code>void Update()</code> method, we create a simple timer by subtracting the time between frames (<code>Time.deltaTime</code>) from an accumulator, which, when less than zero, indicates the cooldown is over. </p> <p>If the cooldown is over and the player is holding the fire button, we shoot and reset the timer.</p> <p>One final thing to change- by default, Button-type actions only trigger when they are pressed down. In order for this to work, we also need to change this Action in the Input Actions to report when the button is released as well.</p> <p>Open up the Input Actions asset, select <code>Fire</code> and press the <code>+</code> dropdown along the header called Interactions on the right. Select Press.</p> <p>Change the <code>Trigger Behavior</code> to <code>Press and Release</code>, then click Save Asset at the top. This will make this Action trigger on both button down and up inputs.</p> <p></p> <p>Run your game and hold down one of the Fire inputs- you now have an auto-firing laser gun!</p> <p></p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#timed-destroy","title":"Timed Destroy","text":"<p>One quick thing. You may have noticed that your shots never disappear and wind up clogging up the Hierarchy (and thusly, unnecessarily consume Memory and CPU usage as they sail into the great beyond).</p> <p>Let's create a component which will automatically destroy the Game Object it is attached to after a couple seconds to help with clean up.</p> <p>Create a new Script <code>TimedDestroy.cs</code>. Add it to the Laser Projectile PREFAB, and edit it:</p> TimedDestroy.cs<pre><code>using UnityEngine;\n\npublic class TimedDestroy : MonoBehaviour\n{\n    [SerializeField, Tooltip(\"Number of seconds after spawning that the object will destroy itself.\")]\n    private float _destroyTime = 6f;\n\n    private float _spawnTime = 0f;\n\n    // Start is called before the first frame update\n    void Start()\n    {\n        _spawnTime = Time.time;\n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        if (Time.time &gt; _spawnTime + _destroyTime)\n            Destroy(gameObject);\n    }\n}\n</code></pre> Abstract <p>Dead simple!</p> <p>We allow the time before destruction to be set in the inspector. Every update, we see if the game time is greater than the time we spawned in at (in <code>Start</code>) plus that destroy time, destroying if so.</p> <p>As you noticed, this is a different way of implementing a timer than we had in the last script. Use whichever one you like better- they're both computationally similar.</p> <p>Your lasers will now despawn after six seconds!</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#chapter-6-spawner","title":"Chapter 6: Spawner","text":"<p>We're almost done! The last thing to do is create some Enemy Spawners which will fire enemies into the play area from afar. This will effectively work like a simplified version of our <code>PlayerLaserGun</code> with a few changes.</p> <p>Create an Empty Game Object in the Hierarchy called Spawner. Position it somewhat to the side of the player so we don't immediately hit them with an Enemy.</p> Game Object Markers <p>For Game Objects that have no Visuals, it can be easy to lose them in the Scene window (You know, on account of them not being visible).</p> <p>In the Inspector window for a selected Game Object, you can click on the Dropdown box to the left of the Name field to assign a marker gizmos to it, making it visible to you.</p> <p>I recommend doing this for the Spawner object.</p> <p></p> <p>If you haven't already, take the Enemy Game Object and drag it into your Prefabs folder to create a Prefab of it. Again, we need to create a Prefab of an object if we would like to Instantiate (spawn) it.</p> <p>Now create a <code>Spawner.cs</code> script, attach it to your Spawner Game Object, and add the following code:</p> Spawner.cs<pre><code>using UnityEngine;\n\npublic class Spawner : MonoBehaviour\n{\n    [SerializeField, Tooltip(\"A game object to spawn.\")]\n    private GameObject _prefab;\n\n    [SerializeField, Tooltip(\"How frequently to spawn game objects in seconds.\")]\n    private float _spawnInterval = 5f;\n\n    private float _spawnTimer = 0f;\n    private bool _isReadyToSpawn = false;\n\n    void Update()\n    {\n        // A simple timer that works by subtracting the time between updates, or frames,\n        // from the timer variable, counting down from whatever the spawn rate is.\n        if (_spawnTimer &gt; 0f)\n        {\n            _spawnTimer -= Time.deltaTime;\n        }\n\n        _isReadyToSpawn = (_spawnTimer &lt;= 0f); // Once the timer counts down to zero, the game object is ready to spawn.\n\n        if (_isReadyToSpawn)\n        {\n            // Randomly create a game object between the specified spawn radius.\n            Instantiate(_prefab, transform.position, transform.rotation);\n            _spawnTimer = _spawnInterval; // Reset the timer.\n            _isReadyToSpawn = false;\n        }\n    }\n}\n</code></pre> <p>Looks pretty similar to the <code>PlayerLaserGun.cs</code>, just like I promised, eh?</p> <p>Go back to the editor, be sure to drag and drop the Enemy Prefab into the <code>Prefab</code> field on the <code>Spawner</code> component for the Spawner, and enter play mode. The object is now shooting Enemies!</p> <p>While we're at it, let's add the <code>TimedDestroy</code> component we made in Chapter 5 to the Enemy PREFAB so that they clean themselves up, too. Set the Destroy time to something a bit longer, like <code>12</code> or <code>15</code> seconds.</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#dispersion","title":"Dispersion","text":"<p>Our spawner is pretty uninteresting right now, because it always spawns Enemies in the exact same direction everytime. This won't do, because we need them to be shot out at various angles to keep things interesting.</p> <p>We can resolve this by adding Dispersion (or Spread) to each Enemy we shoot out. That is to say, when we instantiate a new enemy, we'll rotate it by a random number of degrees off-axis so it flies in different directions each time.</p> <p>Let's give it a shot: Spawner.cs<pre><code>using UnityEngine;\n\npublic class Spawner : MonoBehaviour\n{\n    [SerializeField, Tooltip(\"A game object to spawn.\")]\n    private GameObject _prefab;\n\n    [SerializeField, Tooltip(\"Number of seconds between two consecutive spawns.\")]\n    private float _spawnInterval = 5f;\n\n    [SerializeField, Tooltip(\"The number of degrees on either side of the Y (green) axis to randomly spawn game objects between.\")]\n    private float _spawnDispersion = 30f;\n\n    private float _spawnTimer = 0f;\n    private bool _isReadyToSpawn = false;\n\n    void Update()\n    {\n        // A simple timer that works by subtracting the time between updates, or frames,\n        // from the timer variable, counting down from whatever the spawn rate is.\n        if (_spawnTimer &gt; 0f)\n        {\n            _spawnTimer -= Time.deltaTime;\n        }\n\n        _isReadyToSpawn = _spawnTimer &lt;= 0f; // Once the timer counts down to zero, the game object is ready to spawn.\n\n        if (_isReadyToSpawn)\n        {\n            // Randomly create a game object between the specified spawn radius.\n            GameObject spawnedObject = Instantiate(_prefab, transform.position, transform.rotation);\n\n            float dispersionAngle = Random.Range(-_spawnDispersion, _spawnDispersion); // Create a random offset angle\n            spawnedObject.transform.Rotate(Vector3.forward, dispersionAngle);   // Apply rotation by created offset\n\n            _spawnTimer = _spawnInterval; // Reset the timer.\n            _isReadyToSpawn = false;\n        }\n    }\n}\n</code></pre></p> Abstract <p>As it turns out, the <code>Instantiate</code> method actually returns a reference to the newly created Game Objected created by calling it.</p> <p>Therefore, we can use the <code>Random.Range</code> method to generate an offset rotation (in degrees) and rotate the spawned object's transform by that amount (Again, in 2D, we always rotate around the Z axis, which is <code>Vector3.forward</code> or <code>(0, 0, 1)</code>).</p> <p>Jump in game, you'll notice your spawner has some dispersion now!</p> <p></p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#place-spawners","title":"Place Spawners","text":"<p>The last thing to do is to turn your Spawner Object into a Prefab and place a couple copies of them around the outside of the play area, rotating them to face inwards toward the center. The dispersion will give them wider coverage so there is a possiblity to be hit anywhere on the screen.</p> <p>Note that even though we're not spawning copies of spawners through code, it's still useful to make a Prefab of the spawner so that you can edit all instances of spawners at once just by editing the prefab asset- a great tool for reducing repetitive work down the line.</p> <p>For my example, I placed three Spawners in a loosely triangular fashion around the outside. I also fired their spawn intervals so that they're not all in sync.</p> <p>Once that's done, you've finished this base template!</p> <p></p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#conclusion","title":"Conclusion","text":"<p>Congratulations, you've now got a pretty neat game, and you've learned a fair amount of foundational elements to game development! \\o/</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#what-now","title":"What now?","text":"<p>This game, as is mentioned in the article's title, this tutorial leaves you with a nice template- you can learn a lot by expanding it with your own features and experimenting. There is a lot you can do to make your version of the game unique from everyone else's. You may have already had some ideas, so try and implement them!</p> <p>Just do your best to start small to avoid overwhelming yourself or getting frustrated, and remember that the completed version of this template is available to download off the GitHub page.</p> <p>Keep in mind as well that you can completely charge around the art assets if you're not digging the space theme- the top down controller could be used in something like a hunter dodging leopards in the jungle, ships at sea, or a dungeon crawl. Be creative!</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-base/#ideas-for-expansion","title":"Ideas for Expansion","text":"<p>Here are some ideas of things you could do if you need inspiration:</p> <ul> <li>Add sound effects and particle effects for player / enemy death, laser shooting, flying, etc. This will really make your game pop!</li> <li>Make the enemy's Visuals Game Object rotate to make the asteroids appear to spin through the air.</li> <li>Create a game over screen when the player dies which reports time survived, allows them to restart, and quit the game.</li> <li>Create a main menu before the game starts.</li> <li>Stop the player from flying outside of the screen boundaries.</li> <li>Make the enemies spawn faster as the player survives longer.</li> <li>Create some new enemy types:<ul> <li>A slower but much larger enemy.</li> <li>An enemy which breaks into two smaller ones when destroyed.</li> <li>An enemy which takes multiple shots to destroy.</li> </ul> </li> <li>Make some enemies drop a power up that increases the player's rate of fire.</li> <li>Add some more detail to the background- far off planets, asteroids flying around, etc.</li> </ul>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-index/","title":"Fall 2024 Game Jam Template","text":"<p>By Marceline Gallegos and Jake Rogers</p> <p>Created: February 21st, 2024</p> <p>Updated: September 18th, 2024</p>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-index/#summary","title":"Summary","text":"<p>In this game jam template, we'll teach you how to build up a 2D top-down game where the player has to dodge or shoot asteroids which will destroy them on contact, with asteroids constantly spawning in from the edges of the screen.</p> <p>Being a game template, you are highly encouraged to experiment with this foundation and add your own features! Many are suggested at the bottom of the Base Template Tutorial. Speaking of which, get started at the link below:</p> <ul> <li>Base Template Tutorial (Start Here!)</li> </ul>"},{"location":"tutorials/unity-tutorials/sp24-jam-template/sp24-jam-template-index/#modules","title":"Modules","text":"<p>In the future, we will release additional modules which are tutorials which will expand upon the base template. You'll find them here when they are available!</p>"}]}